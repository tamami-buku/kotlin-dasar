\chapter{Memulai} 

Perlu diketahui bahwa Kotlin ini adalah bahasa pemrograman yang berjalan di atas JVM, sehingga diperlukan Java Runtime untuk menjalankannya.

Cara termudah untuk memasangkan atau meng\textit{install} \textit{compiler} Kotlin adalah dengan mengunduh di halaman \url{https://github.com/JetBrains/kotlin/releases/}, kemudian melakukan \textit{unzip} dan menambahkan direktori \texttt{bin} ke dalam \textit{path} sistem.

Untuk memastikan bahwa Kotlin sudah terpasang dan dapat digunakan, kita seharusnya dapat menjalankan perintah berikut di konsol pada Linux atau \textit{command prompt} milik Windows, berikut perintahnya :

\begin{lstlisting}
kotlinc -version
\end{lstlisting}

Perintah tersebut sebetulnya untuk mencetak informasi tentang versi \textit{compiler} Kotlin yang aktif. Dan seharusnya akan muncul informasi yang kurang lebih sebagai berikut :

\begin{lstlisting}
info: Kotlin Compiler version 1.1.2-2
\end{lstlisting}

Tentunya versi yang keluar akan berbeda tergantung apa yang kita \textit{install}.

Percobaan berikutnya adalah menampilkan versi \textit{runtime environment} dari Kotlin, jika perintah \texttt{kotlinc} digunakan untuk melakukan \textit{compile} (kompilasi) terhadap kode yang kita ketik / tulis menjadi bahasa biner, fungsi dari \textit{runtime environment} adalah menerjemahkan bahasa biner hasil \textit{compile} oleh \texttt{kotlinc} menjadi bahasa \textit{native} sesuai sistem operasi yang digunakan, inilah prinsip yang digunakan bahasa pemrograman Java yang tetap digunakan oleh Kotlin, karena memang Kotlin masih menggunakan JRE (\textit{Java Runtime Environment}).

Perintah untuk melihat versi \textit{runtime environment} dari Kotlin adalah sebagai berikut :

\begin{lstlisting}
kotlin -version
\end{lstlisting}

Dengan hasil keluaran di layar monitor seperti ini :

\begin{lstlisting}
Kotlin version 1.1.2-2 (JRE 1.8.0_121-b13)
\end{lstlisting}

Versi Kotlin seharusnya sama dengan versi \textit{compiler}-nya. Sedangkan muncul tambahan informasi \texttt{JRE 1.8.0\_121-b13}, inilah yang menunjukan bahwa Kotlin masih menggunakan JRE untuk menjalankan programnya, karena memang sebelum melakukan instalasi Kotlin, Java harus di\textit{install} terlebih dahulu.

\section{Katakan Hai}

Setelah melakukan percobaan dasar seperti di atas, kita akan mencoba menjalankan kode pertama yang kita buat dengan Kotlin. Berikut adalah langkahnya :

\begin{enumerate}[1.]
	\item Membuka editor teks seperti notepad, atom, notepad++, atau aplikasi sejenis. 
	\item Mengetikan kode berikut :
	
\begin{lstlisting}
fun main(args: Array<String>) {
    println("Hai, selamat datang")
}
\end{lstlisting}

	\item Simpanlah dengan nama apapun, berikan ekstensi \texttt{kt}, misal kita beri nama \textit{file} tersebut dengan \texttt{Test.kt}.
	\item Buka konsol atau \textit{command prompt} dan aktifkan ke direktori tempat kita simpan \textit{file} \texttt{Test.kt} tadi.
	\item \textit{Compile file} \texttt{Test.kt} tersebut dengan perintah berikut :
	
\begin{lstlisting}
kotlinc Test.kt
\end{lstlisting}

	\item Hasil dari \textit{compile} tersebut adalah berupa \textit{file} \texttt{TestKt.class}
	\item Untuk menjalankan hasil program yang telah kita \textit{compile}, gunakan perintah berikut :
	
\begin{lstlisting}
kotlin TestKt
\end{lstlisting}

	\item Kemudian akan program / aplikasi akan menghasilkan keluaran sebagai berikut :
	
\begin{lstlisting}
Hai, selamat datang
\end{lstlisting}

	\item Sampai titik ini, kita berhasil menjalankan kode yang telah kita buat.
\end{enumerate}

Jadi sebetulnya, untuk memulai koding dengan bahasa Kotlin cukup sederhana, tinggal siapkan \textit{berekstensi} \texttt{kt}, kemudian sertakan blok kode program berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	...
}
\end{lstlisting}

Seluruh program yang dibangun dengan Kotlin akan berawal dari fungsi \texttt{main} ini.

\section{Sintak Dasar}

\subsection{Deklarasi Paket}

Sama seperti bahasa pemrograman Java, deklarasi paket berada di awal kode seperti contoh berikut :

\begin{lstlisting}
package nama.paket

import java.net.*
...
\end{lstlisting}

Perbedaannya adalah bahwa nama paket tidak perlu disesuaikan atau disamakan dengan nama direktorinya seperti pada pemrograman Java. \textit{File} kode sumber dapat ditempatkan dimanapun pada \textit{drive}.

\subsection{Deklarasi Fungsi}

Deklarasi fungsi tanpa parameter dan tanpa nilai balikkan (\textit{return}) akan terlihat seperti contoh kode berikut :

\begin{lstlisting}
fun cetak(): Unit {
	println("Hai, apa kabar")
}
\end{lstlisting}

Atau deklarasi \texttt{Unit} dapat dihilangkan dengan kode akan terlihat seperti ini :

\begin{lstlisting}
fun cetak() {
	println("Hai, apa kabar")
}
\end{lstlisting}

Untuk deklarasi fungsi dengan parameter akan terlihat seperti contoh kode berikut :

\begin{lstlisting}
fun tambah(a: Int, b: Int): Int {
	return a + b
}
\end{lstlisting}

Fungsi yang sama seperti diatas dapat dibuat lebih ringkas dengan nilai balikan \textit{return} yang sudah diprediksi oleh Kotlin, kodenya menjadi seperti berikut ini :

\begin{lstlisting}
fun tambah(a: Int, b: Int) = a + b
\end{lstlisting}

Untuk pembahasan lebih lanjut mengenai fungsi, akan dijabarkan dalam bagian tersendiri dalam buku ini.

\subsection{Deklarasi Variabel}

Deklarasi variabel dapat dilakukan untuk 2 (dua) cara. Yang pertama adalah variabel yang hanya dapat diisi satu kali, dan ada yang dapat diisi berkali-kali. 

Kode untuk deklarasi variabel yang hanya dapat diisi 1 (satu) kali adalah sebagai berikut :

\begin{lstlisting}
val a: Int = 2 
// atau 
val c = 2
// atau
val d: Int
d = 5
\end{lstlisting}

Untuk deklarasi variabel yang dapat diubah, kodenya adalah sebagai berikut :

\begin{lstlisting}
var e = 2
e *= 2
\end{lstlisting}

\subsection{Deklarasi Komentar}

Seperti bahasa pemrograman Java dan Javascript, Kotlin juga menyediakan komentar dalam bentuk komentar baris dan komentar multi-baris. Kode untuk komentar satu baris adalah sebagai berikut :

\begin{lstlisting}
// ini komentar 1 baris
\end{lstlisting}

Untuk kode komentar multi-bari adalah sebagai berikut :

\begin{lstlisting}
/*  ini komentar
    multi baris */
\end{lstlisting}

Namun tidak seperti bahasa pemrograman Java, komentar di Kotlin dapat bersarang bertingkat.

\section{Logat}

Beberapa logat yang biasa digunakan di Kotlin adalah seperti di bawah ini.

\subsection{Membuat Kelas Data}

Kelas data ini biasa digunakan untuk pembuatan kelas \textit{entity}. Contoh kodenya adalah sebagai berikut :

\begin{lstlisting}
data class Pegawai(val nim: String, val nama: String)
\end{lstlisting}

Dengan menambahkan deklarasi \texttt{data} di depan kelas, maka untuk kelas Pegawai ini akan disediakan fungsi-fungsi berikut secara otomatis :

\begin{itemize}
\item \textit{Getters} dan \textit{Setter} untuk seluruh properti
\item \textit{Method} \texttt{equals}.
\item \textit{Method} \texttt{hashCode}
\item \textit{Method} \texttt{toString}
\item \textit{Method} \texttt{copy}
\end{itemize}

\subsection{Nilai \textit{Default} Untuk Parameter Fungsi}

Pada saat deklarasi fungsi, sebetulnya parameter dapat kita isikan dengan nilai \textit{default} seperti berikut :

\begin{lstlisting}
fun isiData(nama: String, kelamin: Int = 0) {
	...
}
\end{lstlisting}

Nantinya parameter \texttt{kelamin} akan terisi otomatis dengan \texttt{0}

Contoh kodenya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val nama = "tamami"
	println("Halo, $nama")
	
	isiData(nama)
}

fun isiData(nama: String, kelamin: Int = 0) {
	println(kelamin)
}
\end{lstlisting}

Hasil keluarannya adalah sebagai berikut :

\begin{lstlisting}
Halo, tamami
0
\end{lstlisting}

Penjelasannya adalah sebagai berikut, pada baris pertama menghasilkan keluaran teks \texttt{Halo, tamami}, yang sebetulnya hasil dari eksekusi perintah kode pada baris ke-3, yaitu :

\begin{lstlisting}
println("Halo, $nama")
\end{lstlisting}

Dimana pemanggilan variabel \texttt{\$nama} pada baris ke-2 dari \textit{source code} terjadi, dan yang ditampilkan di layar monitor adalah isi dari variabel \texttt{\$nama}, yaitu \texttt{tamami}.

Sedangkan pada baris kedua dari hasil keluaran, yaitu \texttt{0}, adalah hasil dari eksekusi kode pada bari ke-9, di dalam fungsi \texttt{isiData}, tepatnya pada perintah berikut :

\begin{lstlisting}
println(kelamin)
\end{lstlisting}

Kenapa hasil keluarannya adalah \texttt{0}, alurnya adalah seperti ini, pada saat pemanggilan fungsi \texttt{isiData(nama)} pada baris ke-5, parameter \texttt{nama} pada fungsi \texttt{isiData} ini terisi dengan nilai \texttt{tamami}, karena parameter kedua, yaitu \texttt{kelamin} tidak disertakan pada pemanggilannya pada baris ke-5, sehingga parameter \texttt{kelamin} akan terisi otomatis dengan nilai \texttt{0} sebagaimana deklarasinya pada baris ke-8.

\subsection{\textit{Interpolasi} Teks}

\textit{Interpolasi} atau penyisipan teks akan terlihat seperti baris perintah berikut ini :

\begin{lstlisting}
val nama: String = "tamami"
println("name $nama")
\end{lstlisting}

Nantinya sisipan teks dengan kode \texttt{\$nama} akan terisi oleh variabel \texttt{nama} yang telah dideklarasikan sebelumnya.

\subsection{Pemeriksaan Instan}

Pada bahasa Kotlin, kita dapat melakukan pemeriksaan tipe data secara instan, formatnya adalah seperti kode berikut :

\begin{lstlisting}
when(x) {
	is String -> ...
	is Int -> ...
	is KelasSaya -> ...
	else -> ...
}
\end{lstlisting}

Artinya nanti isi dari variabel \texttt{x} akan dipilah, apakah merupakan tipe data \texttt{String}, \texttt{Int}, merupakan instan dari kelas \texttt{KelasSaya}, atau berupa tipe data atau kelas lain.

Contoh nyata dari penggunaan kode di atas adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val x: Any = 2
	
	when (x) {
		is String -> println("Jawaban String")
		is Int -> println("Jawaban Int")
		else -> println("lainnya")
	}
}
\end{lstlisting}

Pada kode di atas, tipe data dari variabel \texttt{x} adalah \texttt{Any}, yang artinya bisa berupa tipe data apapun, atau instan dari kelas apapun. Lalu diisikan nilai awal berupa angka 2 (dua).

Selanjutnya kode akan melakukan seleksi tipe data \texttt{x} pada baris ke-4 dengan perintah \texttt{when (x)}, kemudian melakukan pemeriksaan, apabila tipe data dari variabel \texttt{x} adalah \texttt{String} maka akan dicetak seperti pada baris ke-5 dari kode di atas, tapi ternyata memang tipe data yang tepat adalah pada baris ke-6 sehingga program yang kita bangun akan mencetak \texttt{Jawaban Int} di layar, karena variabel \texttt{x} berisi angka 2 (dua).

\subsection{Penggunaan \textit{Range}}

Penggunaan \textit{range} biasanya untuk melakukan iterasi atau perulangan, beberapa contohnya akan dikerjakan dengan kode berikut :

\begin{lstlisting}
for(i in 1..10) { println("data ke-$i = $i") }
\end{lstlisting}

Kode tersebut akan menghasilkan keluaran di monitor dimana nilai \texttt{i} dari 1 sampai dengan 10 sebagai berikut :

\begin{lstlisting}
data ke-1 = 1
data ke-2 = 2
data ke-3 = 3
data ke-4 = 4
data ke-5 = 5
data ke-6 = 6
data ke-7 = 7
data ke-8 = 8
data ke-9 = 9
data ke-10 = 10
\end{lstlisting}

Contoh penggunaan \textit{range} yang lain adalah seperti kode berikut :

\begin{lstlisting}
for(i in 1 until 10) { println("data ke-$i = $i") }
\end{lstlisting}

Sama seperti kode sebelumnya, hanya saja kali ini nilai \texttt{i} adalah antara 1 sampai dengan 9, angka 10 tidak masuk dalam kualifikasi proses cetak ke monitor. Berikut adalah hasil keluarannya di monitor :

\begin{lstlisting}
data ke-1 = 1
data ke-2 = 2
data ke-3 = 3
data ke-4 = 4
data ke-5 = 5
data ke-6 = 6
data ke-7 = 7
data ke-8 = 8
data ke-9 = 9
\end{lstlisting}

Contoh penggunaan \textit{range} dengan beberapa pola lompatan atau kelipatan angka adalah sebagai berikut :

\begin{lstlisting}
for(i in 1..10 step 3) { println("data ke-$i") }
\end{lstlisting}

Maksudnya adalah mencetak deretan angka yang dimulai dari 1 dengan kelipatan 3 sampai nilai \texttt{i} sama dengan 10. Berikut adalah hasil keluaran dari kode tersebut :

\begin{lstlisting}
data ke-1
data ke-4
data ke-7
data ke-10
\end{lstlisting}

Contoh penggunaan \textit{range} untuk perulangan yang mundur ke nilai yang lebih kecil adalah sebagai berikut :

\begin{lstlisting}
for(i in 10 downTo 1) { println("data ke-$i") }
\end{lstlisting}

Penjelasan dari kode tersebut dijelaskan dengan hasil keluaran di layar monitor sebagai berikut :

\begin{lstlisting}
data ke-10
data ke-9
data ke-8
data ke-7
data ke-6
data ke-5
data ke-4
data ke-3
data ke-2
data ke-1
\end{lstlisting}

\subsection{\textit{Read-only List}}

Artinya adalah membuat \textit{list} yang tidak dapat diubah isinya, contoh deklarasinya adalah sebagai berikut :

\begin{lstlisting}
val list = listOf("data A", "data B", "data C")
\end{lstlisting}

Untuk lebih jelasnya, kita akan melihat kode contoh sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val list = listOf("A", "B", "C");
	
	for(i in list) {
		println("data $i")	
	]
}
\end{lstlisting}

Kode tersebut, pada baris ke-2 adalah menyiapkan objek \textit{list} dan diisikan langsung dengan data menggunakan perintah \texttt{listOf}, selanjutnya seluruh data dicetak ke layar monitor sebagaimana tampilan berikut :

\begin{lstlisting}
data A
data B
data C
\end{lstlisting}

\subsection{\textit{Read-only Map} dan Cara Mengaksesnya}

\textit{Map} sebetulnya adalah kelas koleksi yang berisi pasangan kunci (\textit{key}) dan isi (\textit{value}), contohnya adalah sebagai berikut :

\begin{lstlisting}
val map = mapOf("key1" to "nilai1", "key2" to "nilai2", "key3" to "nilai3")
\end{lstlisting}

Untuk melakukan akses data pada \textit{map} ini adalah sebagai berikut :

\begin{lstlisting}
println(map["key"]) // untuk mengambil nilainya
map["key"] = nilai // untuk mengganti atau mengisi nilai
\end{lstlisting}

Kode lengkap untuk percobaan \textit{Map} ini adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val map = mapOf("key1" to "nilai1", "key2" to "nilai2", "key3" to "nilai3")
	
	println(map["key2"])
	
	for(i in map) {
		println(i)
	}
}
\end{lstlisting}

Hasil keluarannya adalah sebagai berikut :

\begin{lstlisting}
nilai2
key1=nilai1
key2=nilai2
key3=nilai3
\end{lstlisting}

Hasil dari kode pada baris ke-4 adalah hasil keluaran pada baris ke-1, sedangkan hasil iterasi atau perulangan dari kode pada baris ke-6 sampai dengan baris ke-8 adalah pada baris ke-2 sampai dengan baris ke-4 pada hasil keluaran.

\subsection{Jalan Pintas Perintah \texttt{if not null}}

Ini digunakan sebetulnya untuk melakukan pemeriksaan terhadap isi dari suatu variabel apakah terisi atau tidak (\textit{null}), kodenya adalah sebagai berikut :

\begin{lstlisting}
import java.io.File

fun main(args: Array<String>) {
	val file = File("Test.kt").listFiles()
	
	println(file ?. getTotalSpace())
}
\end{lstlisting}

Pada kode tersebut kita melihat bahwa aplikasi yang kita bangun menggunakan pustaka Java yaitu \texttt{java.io.File}, hal ini memungkinkan karena memang Kotlin adalah turunan dari Java yang dapat menggunakan kelas-kelas Java untuk membangun aplikasi. Ini adalah salah fasilitas yang Kotlin sediakan.

Yang perlu diperhatikan adalah pada baris ke-6, yaitu pada bagian \texttt{file?.getTotalSpace()}, dimana tanda tanya (\texttt{?}) yang ada pada bagian ini menunjukan seleksi atau pemeriksaan terhadap kondisi \textit{null}, atau kosongnya isi dari variabel yang diminta.

Bila isi variabel \texttt{file} ada isinya, maka akan dicetak ukuran dari \textit{file} tersebut, namun bila nihil, maka akan mencetak \texttt{null} ke layar monitor.

Sebagai contoh apabila isi dari variabel \texttt{file} adalah \texttt{null} adalah sebagai berikut :

\begin{lstlisting}
import java.io.File

fun main(args: Array<String>) {
	val file: File?
	file = null
	println(file?.getTotalSpace())
}
\end{lstlisting}

Hasil dari kode di atas adalah informasi \texttt{null} yang dicetak ke layar monitor.

\subsection{Jalan Pintas Perintah \texttt{if not null and else}}

Cara ini sebetulnya pengembangan dari kasus sebelumnya, dengan penambahan penanganan apabila memang hasilnya adalah \texttt{null}, berikut kodenya :

\begin{lstlisting}
import java.io.File

fun main(args: Array<String>) {
	val file: File?
	file = null
	println(file ?. getTotalSpace() ?: "NIHIL")
}
\end{lstlisting}

Yang perlu diperhatikan adalah pada baris ke-6, dimana ada tambahan tanda (\texttt{?:}), apabila variabel \texttt{file} tidak bernilai \texttt{null} maka akan dipanggil \textit{method} \texttt{getTotalSpace()}, namun bila bernilai \texttt{null} maka akan dicetak kata \texttt{NIHIL}.

\subsection{Eksekusi Perintah \texttt{if null}}

Kondisi ini digunakan untuk melakukan eksekusi bila nilai dari suatu variabel bernilai \texttt{null}. Contoh kode untuk kasus ini adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = mapOf("nama" to "tamami", "umur" to 36)
	val email = data["email"] ?: throw IllegalStateException("Email tidak ada")
}
\end{lstlisting}

Inti dari kode ini sebetulnya ada pada baris ke-3, pada saat variabel \texttt{email} akan diisikan sebuah nilai yang diambilkan dari variabel \textit{map} \texttt{data} berupa \textit{email}, namun bila nilai untuk \textit{email} ini \texttt{null} maka akan dilemparkan keluar sebagai \texttt{IllegalStateException}.

Hasil keluaran dari kode tersebut tentu saja sebuah \textit{exception} dengan pesan berupa \texttt{Email tidak ada}.

\subsection{Eksekusi Perintah \texttt{if not null}}

Kondisi ini adalah kebalikan dari eksekusi sebelumnya, yaitu bila nilainya tidak \texttt{null} maka akan melakukan eksekusi yang tertuang dalam blok kode. Berikut ada contoh kodenya :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = mapOf("nama" to "tamami", "umur" to 33)
	data?.let {
		println(data["nama"])
	}
}
\end{lstlisting}

Blok kode untuk kondisi ini sebetulnya ada pada baris ke-3 sampai dengan baris ke-5, pada baris ke-3, akan dilakukan pemeriksaan, apakah variabel \texttt{data} berupa \texttt{null} atau bukan, bila bukan \texttt{null} maka akan dikerjakan perintah pada baris ke-4. Bila berupa \texttt{null} maka blok kode ini akan dilewati begitu saja.

\subsection{Kembalikan Pada Perintah \texttt{when}}

Pada bagian ini, sebuah \textit{method} akan mengembalikan nilai dari hasil seleksi pada perintah \texttt{when}. Berikut kode lengkapnya :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("Kode warna " + kodeWarna("hijau"))
}

fun kodeWarna(warna: String): Int {
	return when(warna) {
		"merah" -> 1
		"hijau" -> 2
		"biru" -> 3
		else -> throw Exception("Salah Warna")
	}
}
\end{lstlisting}

Pada bagian ini intinya ada pada \textit{method} atau fungsi \texttt{kodeWarna}, yaitu bila parameter \texttt{warna} terisi oleh teks \texttt{merah} maka akan mengembalikan nilai \texttt{1}, bila terisi oleh teks \texttt{hijau} maka akan mengembalikan nilai \texttt{2} dan seterusnya.

Pada baris ke-2, karena dipanggil fungsi \texttt{kodeWarna} dengan parameter \texttt{warna} berisi teks \texttt{hijau}, maka hasil keluaran yang terjadi di layar monitor adalah sebagai berikut :

\begin{lstlisting}
Kode warna 2
\end{lstlisting}

\subsection{Ekspresi \texttt{try catch}}

Pada bagian ini ditujukan untuk penanganan \textit{exception} dengan \texttt{try catch} agar aplikasi yang dibangun lebih bersih dari informasi kesalahan yang diproduksi oleh bahasa pemrograman. Contoh kode untuk penjelasannya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	try {
		println("kode warna : " + kodeWarna("ungu"))
	} catch(e: Exception) {
		println("error : " + e.printStackTrace())
	}
}

fun kodeWarna(warna: String): Int {
	return when(warna) {
		"merah" -> 1
		"hijau" -> 2
		"biru" -> 3
		else -> throw Exception("Salah Warna")
	}
}
\end{lstlisting}

Pada baris ke-3, sengaja diberikan isi teks \texttt{ungu} pada parameter fungsi \texttt{kodeWarna} agar \textit{exception} yang ada dapat dipicu untuk dieksekusi.

Hasilnya adalah karena parameter teks \texttt{ungu} yang dikirim, maka yang diterima adalah \textit{exception} pada baris ke-14, sehingga kode akan langsung dilempar ke baris ke-5 karena pemanggilan fungsi \texttt{kodeWarna} menghasilkan \textit{exception} tersebut.

\subsection{Ekspresi \texttt{if}}

Pada bagian ini, sebetulnya berfungsi untuk kondisional biasa, untuk memilah sebagaimana bentuk \textit{when} sebelumnya. Contoh kodenya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val i = 37
	
	if(i % 2 == 0) {
		println("itu bilangan genap")
	} else {
		println("itu bilangan ganjil")
	}
}
\end{lstlisting}

Tentu saja hasil dari kode tersebut akan mencetak baris teks berikut :

\begin{lstlisting}
itu bilangan ganjil
\end{lstlisting}

Karena memang nilai dari variabel \texttt{i} diperiksa, apabila setelah dibagi dengan angka 2 tidak memiliki sisa bagi, maka itu pertanda bahwa nilai \texttt{i} adalah bilangan genap, namun bila selain dari itu, akan dieksekusi perintah dalam blok \texttt{else}.

\section{Adat}

Pada tiap bahasa pemrograman, ada sebuah adat atau kebiasaan atau \textit{style} dari kode agar tetap mudah terbaca bagi orang lain yang membuka kode sumbernya, begitu pula di Kotlin, ada beberapa kebiasan atau adat yang perlu kita latih agar kode kita mudah untuk dibaca oleh orang lain. Berikut adalah diantaranya :

\begin{itemize}
	\item Gaya Penamaan
	\item Titik Dua
	\item Lamda
	\item Format \textit{Header} Kelas
	\item Unit
	\item Fungsi vs. Properti
\end{itemize}