\chapter{Java Interoperabilitas}

Karna Kotlin melakukan kompilasi ke dalam kelas Java, maka sebetulnya Kotlin mampu untuk menggunakan pustaka-pustaka yang ditulis dan dibangun menggunakan bahasa Java. Begitu pula sebaliknya.

\section{Gunakan Java di Kotlin}

Kotlin dibangun dengan memikirkan penggabungannya dengan pustaka Java. Kode yang dibangun di Java dapat dengan mudah digunakan di Kotlin, begitu pula sebaliknya. Coba perhatikan kode yang ditulis dalam bahasa Kotlin yang menggunakan pustaka \texttt{ArrayList} dari Java :

\begin{lstlisting}
import java.util.ArrayList;

fun main(args: Array<String>) {
	val list = ArrayList<Int>()
	
	list.add(1)
	list.add(4)
	list.add(7)
	
	for(i in list) {
		println(i)
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
1
4
7
\end{lstlisting}

Terlihat bahwa kode di atas menggunakan kelas \texttt{ArrayList} yang ada pada pustaka Java.

\subsection{Fungsi \textit{Getter} dan \textit{Setter}}

Untuk fungsi \textit{getter} dan \textit{setter}, di Kotlin akan dikenal sebagai properti. Jadi misalkan ada fungsi \textit{getter} dan \textit{setter}-nya di Java, cukup dipanggil nama propertinya saja.

Perhatikan kode Java berikut ini :

\begin{lstlisting}
public class Pegawai {
	private String nama;
	
	public void setNama(String nama) {
		this.nama = nama;
	}
	
	public String getNama() {
		return nama;
	}
}
\end{lstlisting}

Kode tersebut dapat di\textit{compile} dengan \texttt{javac} kemudian nantinya akan kita gunakan pada kode Kotlin berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai = Pegawai()
	
	pegawai.nama = "tamami"
	
	println(pegawai.nama)
}
\end{lstlisting}

Yang perlu di perhatikan untuk \textit{compile} kode di atas adalah, kelas \texttt{Pegawai} yang dibuat dengan kode Java harus dalam 1 (satu) direktori dengan \textit{file} Kotlin yang kita buat.

\textit{Compile} terlebih dahulu kelas \texttt{Pegawai} agar dapat digunakan. Untuk melakukan \textit{compile file} Kotlin harus menggunakan opsi \textit{classpath} seperti berikut ini (misalkan nama \textit{file} Kotlin yang saya buat adalah \texttt{Test.kt}) :

\begin{lstlisting}
kotlinc -cp . Test.kt
\end{lstlisting}

Begitu pula pada saat kita akan menjalankan aplikasi Kotlin yang telah kita buat, gunakan opsi \textit{classpath} seperti berikut ini :

\begin{lstlisting}
kotlin -cp . TestKt
\end{lstlisting}

Hasil keluarannya akan tampak seperti berikut ini :

\begin{lstlisting}
tamami
\end{lstlisting}

Terlihat bahwa pada kode Kotlin yang telah kita buat, kita menggunakan kelas \texttt{Pegawai} dari bahasa Java. Kemudian melakukan akses ke properti \texttt{nama} milik kelas \texttt{Pegawai} dengan memberinya nilai seperti pada baris ke-4.

Pada saat melakukan pengambilan data seperti pada baris ke-6 pun, cukup melakukan akses ke nama propertinya yang Kotlin akan menerjemahkan untuk melakukan akses atau mengambil nilai dengan fungsi \texttt{getNama} yang ada di Java.

Bagaimana jika properti di Java hanya memiliki sebuah \textit{method} \texttt{set} saja di dalamnya, maka Kotlin tidak akan bisa melakukan akses terhadap properti ini, yang dapat kita lakukan adalah dengan melakukan akses langsung terhadap nama fungsinya. Dijelaskan dengan kode (kita ubah kode Java sebelumnya) adalah sebagai berikut :

\begin{lstlisting}
public class Pegawai {
	private String nama;
	
	public void setNama(String nama) {
		this.nama = nama;
	}
}
\end{lstlisting}

Maka kode di Kotlin akan melakukan akses dengan cara berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai : Pegawai()
	
	pegawai.setNama("tamami")
}
\end{lstlisting}

\subsection{Nilai Kembalian \texttt{void}}

Saat sebuah \textit{method} mengembalikan nilai \texttt{void} di Java, maka dalam Kotlin akan digantikan dengan kelas \texttt{Unit} pada saat \textit{compile}.

\subsection{Kata Kunci di Kotlin Jadi Nama \textit{Method} di Java}

Bila di Java menggunakan nama \textit{method} yang sama dengan kata kunci di Kotlin seperti \texttt{is}, \texttt{in}, \texttt{object}, dan lainnya, kita masih dapat menggunakannya dengan cara memberikan tanda \textit{backtick}. Berikut contoh kode di Javanya :

\begin{lstlisting}
public class Pegawai {
	private String bagian;
	
	public Pegawai(String bagian) {
		this.bagian = bagian;
	}
		
	public boolean in(String bagian) {
		if(bagian.equals(this.begin)) return true;
		else return false;
	}
}
\end{lstlisting}

Kita lihat pada baris ke-8 bahwa \textit{method} dengan nama \texttt{in} ada di Java, untuk melakukan akses terhadap \textit{method} ini di Kotlin adalah dengan cara berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai = Pegawai("dattap")
	
	if(pegawai.`in`("dattap")) println("betul") else println("lain")
}
\end{lstlisting}

Untuk memanggil \textit{method} \texttt{in} seperti terlihat pada baris ke-4 di atas.

\subsection{\textit{Null-Safety}}

Di Java ada kemungkinan variabel atau properti yang ada dalam sebuah kelas bernilai \texttt{null} sedangkan Kotlin akan menjaga agar tidak ada satu variabel atau properti yang bernilai \texttt{null} pada saat melakukan \textit{compile}, lalu bagaimana solusinya, perhatikan 2 (dua) kode berikut.

Kode yang pertama di tulis dalam Java dan memiliki peluang untuk memberikan nilai \texttt{null} pada kelas yang melakukan akses terhadap properti \texttt{nama}. Berikut kodenya :

\begin{lstlisting}
public class Pegawai {
	private String nama;
	
	public void setNama(String nama) {
		this.nama = nama;
	}
	
	public String getNama() {
		return nama;
	}
}
\end{lstlisting}

Kita dapat menggunakan operator tanda tanya (\texttt{?}) untuk menampung data yang mungkin akan menghasilkan nilai \texttt{null} dari kelas \texttt{Pegawai} di atas, berikut kodenya di Kotlin :

\begin{lstlisting}
import java.util.ArrayList

fun main(args: Array<String>) {
	val list = ArrayList<String>()
	list.add("data")
	
	val pegawai = Pegawai()
	
	val boleh: String? = pegawai.nama
	val tidak: String = list[0]
	
	println(boleh)
	println(tidak)
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
null
data
\end{lstlisting}

Pada baris ke-9 dari kode Kotlin yang kita buat, ada operator tanda tanya (\texttt{?}) disana yang akan memberikan kelonggaran, atau melewatkan pemeriksaan atas properti \texttt{nama} milik kelas \texttt{Pegawai} yang dimungkinkan bernilai \texttt{null}. Dan benar saja, pada saat dicetak seperti pada baris ke-12, hasilnya adalah \texttt{null}.

Selain itu, ada saatnya sebuah tipe data yang tidak dapat disebutkan secara eksplisit, apakah \texttt{null} atau apakah nilainya ada, yang biasa disebut tipe \textit{platform}. Untuk kasus ini bisa menggunakan notasi tanda seru (\texttt{!}) setelah tipe datanya. Misalkan untuk tipe data \texttt{T}, dapat menggunakan \texttt{T!} yang artinya dapat berupa data yang mungkin \texttt{null} seperti notasi \texttt{T?} atau tipe data yang pasti bukan \texttt{null} seperti tanda \texttt{T}.

\subsection{Persamaan Tipe Data}

Dari percobaan sebelumnya, kita telah ketahui bahwa tipe data primitif Java tidak diterjemahkan seperti data primitif di Kotlin, namun akan dipetakan ke bentuk kelas, beberapa pemetaan yang dilakukan untuk tipe data primitif adalah sebagai berikut :

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin} \\
\hline
byte & kotlin.Byte \\
\hline
short & kotlin.Short \\
\hline
int & kotlin.Int \\
\hline
long & kotlin.Long \\
\hline
char & kotlin.Char \\
\hline 
float & kotlin.Float \\
\hline
double & kotlin.Double \\
\hline
boolean & kotlin.Boolean \\
\hline
\end{tabular}
\end{center}

Beberapa tipe data yang bukan termasuk ke tipe data primitif pun akan dipetakan sebagai berikut di Kotlin :

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin} \\
\hline
java.lang.Object & kotlin.Any! \\
\hline
java.lang.Cloneable & kotlin.Cloneable! \\
\hline
java.lang.Comparable & kotlin.Comparable! \\
\hline
java.lang.Enum & kotlin.Enum! \\
\hline
java.lang.Annotation & kotlin.Annotation! \\
\hline
java.lang.Deprecated & kotlin.Deprecated! \\
\hline
java.lang.CharSequence & kotlin.CharSequence! \\
\hline
java.lang.String & kotlin.String! \\
\hline
java.lang.Number & kotlin.Number! \\
\hline
java.lang.Throwable & kotlin.Throwable! \\
\hline
\end{tabular}
\end{center}

Beberapa tipe data primitif yang dibentuk dalam kelas juga akan dipetakan di Kotlin seperti berikut ini :

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin} \\
\hline
java.lang.Byte & kotlin.Byte? \\
\hline
java.lang.Short & kotlin.Short? \\
\hline
java.lang.Integer & kotlin.Int? \\
\hline
java.lang.Long & kotlin.Long? \\
\hline
java.lang.Char & kotlin.Char? \\
\hline
java.lang.Float & kotlin.Float? \\
\hline
java.lang.Double & kotlin.Double? \\
\hline
java.lang.Boolean & kotlin.Boolean? \\
\hline
\end{tabular}
\end{center}

\textit{Collection} di Kotlin bisa berupa \textit{read-only} atau dapat diubah, jadi ketentuan \textit{collection} di Java akan berlaku seperti ini :

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin \textit{read-only}} & \textbf{Kotlin dapat diubah} & \textbf{Kotlin \textit{Platform}} \\
\hline
Iterator<T> & Iterator<T> & MutableIterator<T> & (Mutable) Iterator<T>! \\
\hline
Iterable<T> & Iterable<T> & MutableIterable<T> & (Mutable) Iterable<T>! \\
\hline
Collection<T> & Collection<T> & MutableCollection<T> & (Mutable) Collection<T>! \\
\hline
Set<T> & Set<T> & MutableSet<T> & (Mutable) Set<T>! \\
\hline
List<T> & List<T> & MutableList<T> & (Mutable) List<T>! \\
\hline
ListIterator<T> & ListIterator<T> & MutableListIterator<T> & (Mutable) ListIterator<T>! \\
\hline
Map<K, V> & Map<K, V> & MutableMap<K, V> & (Mutable) Map<K, V>! \\
\hline
Map.Entry<K, V> & Map.Entry<K, V> & MutableMap.MutableEntry<K, V> & (Mutable) Map.(Mutable)Entry<K, V>
\end{tabular}
\end{center}

Semua kelas di atas berada dalam paket \texttt{kotlin.collections}.

Untuk larik sendiri, di Kotlin akan diterjemahkan sebagai berikut :

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin} \\
\hline
int[] & kotlin.IntArray! \\
\hline
String[] & kotlin.Array<(out) String>! \\
\hline
\end{tabular}
\end{center}

\subsection{Java Generik}

\subsection{Larik Java}

Untuk larik, ingatlah bahwa larik di Kotlin berbeda dengan larik di Java. Di Kotlin tidak diperbolehkan mengisikan data dari sub-kelas atau super-kelas, contohnya misalkan deklarasi yang disebutkan adalah \texttt{Array<Any>}, deklarasi tersebut tidak bisa diisikan dengan data seperti \texttt{Array<String>}. Dan untuk tipe data primitif di Java, ada kelas yang bertugas menangani masing-masing tipe data tersebut dalam larik seperti \texttt{IntArray}, \texttt{CharArray}, \texttt{FloatArray} dan seterusnya.

\subsection{Varargs di Java}

\subsection{Operator}

\subsection{Pemeriksaan \textit{Exception}}

\subsection{\textit{Method} Kelas Objek di Java}

\subsection{Mewarisi dari Kelas Java}

\subsection{Mengakses \texttt{static}}

\subsection{Java Reflection}

\subsection{Konversi SAM}

\subsection{Menggunakan JNI di Kotlin}

\section{Gunakan Kotlin di Java}