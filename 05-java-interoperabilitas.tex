\chapter{Java Interoperabilitas}

Karna Kotlin melakukan kompilasi ke dalam kelas Java, maka sebetulnya Kotlin mampu untuk menggunakan pustaka-pustaka yang ditulis dan dibangun menggunakan bahasa Java. Begitu pula sebaliknya.

\section{Gunakan Java di Kotlin}

Kotlin dibangun dengan memikirkan penggabungannya dengan pustaka Java. Kode yang dibangun di Java dapat dengan mudah digunakan di Kotlin, begitu pula sebaliknya. Coba perhatikan kode yang ditulis dalam bahasa Kotlin yang menggunakan pustaka \texttt{ArrayList} dari Java :

\begin{lstlisting}
import java.util.ArrayList;

fun main(args: Array<String>) {
	val list = ArrayList<Int>()
	
	list.add(1)
	list.add(4)
	list.add(7)
	
	for(i in list) {
		println(i)
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
1
4
7
\end{lstlisting}

Terlihat bahwa kode di atas menggunakan kelas \texttt{ArrayList} yang ada pada pustaka Java.

\subsection{Fungsi \textit{Getter} dan \textit{Setter}}

Untuk fungsi \textit{getter} dan \textit{setter}, di Kotlin akan dikenal sebagai properti. Jadi misalkan ada fungsi \textit{getter} dan \textit{setter}-nya di Java, cukup dipanggil nama propertinya saja.

Perhatikan kode Java berikut ini :

\begin{lstlisting}
public class Pegawai {
	private String nama;
	
	public void setNama(String nama) {
		this.nama = nama;
	}
	
	public String getNama() {
		return nama;
	}
}
\end{lstlisting}

Kode tersebut dapat di\textit{compile} dengan \texttt{javac} kemudian nantinya akan kita gunakan pada kode Kotlin berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai = Pegawai()
	
	pegawai.nama = "tamami"
	
	println(pegawai.nama)
}
\end{lstlisting}

Yang perlu di perhatikan untuk \textit{compile} kode di atas adalah, kelas \texttt{Pegawai} yang dibuat dengan kode Java harus dalam 1 (satu) direktori dengan \textit{file} Kotlin yang kita buat.

\textit{Compile} terlebih dahulu kelas \texttt{Pegawai} agar dapat digunakan. Untuk melakukan \textit{compile file} Kotlin harus menggunakan opsi \textit{classpath} seperti berikut ini (misalkan nama \textit{file} Kotlin yang saya buat adalah \texttt{Test.kt}) :

\begin{lstlisting}
kotlinc -cp . Test.kt
\end{lstlisting}

Begitu pula pada saat kita akan menjalankan aplikasi Kotlin yang telah kita buat, gunakan opsi \textit{classpath} seperti berikut ini :

\begin{lstlisting}
kotlin -cp . TestKt
\end{lstlisting}

Hasil keluarannya akan tampak seperti berikut ini :

\begin{lstlisting}
tamami
\end{lstlisting}

Terlihat bahwa pada kode Kotlin yang telah kita buat, kita menggunakan kelas \texttt{Pegawai} dari bahasa Java. Kemudian melakukan akses ke properti \texttt{nama} milik kelas \texttt{Pegawai} dengan memberinya nilai seperti pada baris ke-4.

Pada saat melakukan pengambilan data seperti pada baris ke-6 pun, cukup melakukan akses ke nama propertinya yang Kotlin akan menerjemahkan untuk melakukan akses atau mengambil nilai dengan fungsi \texttt{getNama} yang ada di Java.

Bagaimana jika properti di Java hanya memiliki sebuah \textit{method} \texttt{set} saja di dalamnya, maka Kotlin tidak akan bisa melakukan akses terhadap properti ini, yang dapat kita lakukan adalah dengan melakukan akses langsung terhadap nama fungsinya. Dijelaskan dengan kode (kita ubah kode Java sebelumnya) adalah sebagai berikut :

\begin{lstlisting}
public class Pegawai {
	private String nama;
	
	public void setNama(String nama) {
		this.nama = nama;
	}
}
\end{lstlisting}

Maka kode di Kotlin akan melakukan akses dengan cara berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai : Pegawai()
	
	pegawai.setNama("tamami")
}
\end{lstlisting}

\subsection{Nilai Kembalian \texttt{void}}

Saat sebuah \textit{method} mengembalikan nilai \texttt{void} di Java, maka dalam Kotlin akan digantikan dengan kelas \texttt{Unit} pada saat \textit{compile}.

\subsection{Kata Kunci di Kotlin Jadi Nama \textit{Method} di Java}

Bila di Java menggunakan nama \textit{method} yang sama dengan kata kunci di Kotlin seperti \texttt{is}, \texttt{in}, \texttt{object}, dan lainnya, kita masih dapat menggunakannya dengan cara memberikan tanda \textit{backtick}. Berikut contoh kode di Javanya :

\begin{lstlisting}
public class Pegawai {
	private String bagian;
	
	public Pegawai(String bagian) {
		this.bagian = bagian;
	}
		
	public boolean in(String bagian) {
		if(bagian.equals(this.begin)) return true;
		else return false;
	}
}
\end{lstlisting}

Kita lihat pada baris ke-8 bahwa \textit{method} dengan nama \texttt{in} ada di Java, untuk melakukan akses terhadap \textit{method} ini di Kotlin adalah dengan cara berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai = Pegawai("dattap")
	
	if(pegawai.`in`("dattap")) println("betul") else println("lain")
}
\end{lstlisting}

Untuk memanggil \textit{method} \texttt{in} seperti terlihat pada baris ke-4 di atas.

\subsection{\textit{Null-Safety}}

Di Java ada kemungkinan variabel atau properti yang ada dalam sebuah kelas bernilai \texttt{null} sedangkan Kotlin akan menjaga agar tidak ada satu variabel atau properti yang bernilai \texttt{null} pada saat melakukan \textit{compile}, lalu bagaimana solusinya, perhatikan 2 (dua) kode berikut.

Kode yang pertama di tulis dalam Java dan memiliki peluang untuk memberikan nilai \texttt{null} pada kelas yang melakukan akses terhadap properti \texttt{nama}. Berikut kodenya :

\begin{lstlisting}
public class Pegawai {
	private String nama;
	
	public void setNama(String nama) {
		this.nama = nama;
	}
	
	public String getNama() {
		return nama;
	}
}
\end{lstlisting}

Kita dapat menggunakan operator tanda tanya (\texttt{?}) untuk menampung data yang mungkin akan menghasilkan nilai \texttt{null} dari kelas \texttt{Pegawai} di atas, berikut kodenya di Kotlin :

\begin{lstlisting}
import java.util.ArrayList

fun main(args: Array<String>) {
	val list = ArrayList<String>()
	list.add("data")
	
	val pegawai = Pegawai()
	
	val boleh: String? = pegawai.nama
	val tidak: String = list[0]
	
	println(boleh)
	println(tidak)
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
null
data
\end{lstlisting}

Pada baris ke-9 dari kode Kotlin yang kita buat, ada operator tanda tanya (\texttt{?}) disana yang akan memberikan kelonggaran, atau melewatkan pemeriksaan atas properti \texttt{nama} milik kelas \texttt{Pegawai} yang dimungkinkan bernilai \texttt{null}. Dan benar saja, pada saat dicetak seperti pada baris ke-12, hasilnya adalah \texttt{null}.

Selain itu, ada saatnya sebuah tipe data yang tidak dapat disebutkan secara eksplisit, apakah \texttt{null} atau apakah nilainya ada, yang biasa disebut tipe \textit{platform}. Untuk kasus ini bisa menggunakan notasi tanda seru (\texttt{!}) setelah tipe datanya. Misalkan untuk tipe data \texttt{T}, dapat menggunakan \texttt{T!} yang artinya dapat berupa data yang mungkin \texttt{null} seperti notasi \texttt{T?} atau tipe data yang pasti bukan \texttt{null} seperti tanda \texttt{T}.

\subsection{Persamaan Tipe Data}

Dari percobaan sebelumnya, kita telah ketahui bahwa tipe data primitif Java tidak diterjemahkan seperti data primitif di Kotlin, namun akan dipetakan ke bentuk kelas, beberapa pemetaan yang dilakukan untuk tipe data primitif adalah sebagai berikut :

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin} \\
\hline
byte & kotlin.Byte \\
\hline
short & kotlin.Short \\
\hline
int & kotlin.Int \\
\hline
long & kotlin.Long \\
\hline
char & kotlin.Char \\
\hline 
float & kotlin.Float \\
\hline
double & kotlin.Double \\
\hline
boolean & kotlin.Boolean \\
\hline
\end{tabular}
\end{center}

Beberapa tipe data yang bukan termasuk ke tipe data primitif pun akan dipetakan sebagai berikut di Kotlin :

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin} \\
\hline
java.lang.Object & kotlin.Any! \\
\hline
java.lang.Cloneable & kotlin.Cloneable! \\
\hline
java.lang.Comparable & kotlin.Comparable! \\
\hline
java.lang.Enum & kotlin.Enum! \\
\hline
java.lang.Annotation & kotlin.Annotation! \\
\hline
java.lang.Deprecated & kotlin.Deprecated! \\
\hline
java.lang.CharSequence & kotlin.CharSequence! \\
\hline
java.lang.String & kotlin.String! \\
\hline
java.lang.Number & kotlin.Number! \\
\hline
java.lang.Throwable & kotlin.Throwable! \\
\hline
\end{tabular}
\end{center}

Beberapa tipe data primitif yang dibentuk dalam kelas juga akan dipetakan di Kotlin seperti berikut ini :

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin} \\
\hline
java.lang.Byte & kotlin.Byte? \\
\hline
java.lang.Short & kotlin.Short? \\
\hline
java.lang.Integer & kotlin.Int? \\
\hline
java.lang.Long & kotlin.Long? \\
\hline
java.lang.Char & kotlin.Char? \\
\hline
java.lang.Float & kotlin.Float? \\
\hline
java.lang.Double & kotlin.Double? \\
\hline
java.lang.Boolean & kotlin.Boolean? \\
\hline
\end{tabular}
\end{center}

\textit{Collection} di Kotlin bisa berupa \textit{read-only} atau dapat diubah, jadi ketentuan \textit{collection} di Java akan berlaku seperti ini :

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin \textit{read-only}} & \textbf{Kotlin dapat diubah} & \textbf{Kotlin \textit{Platform}} \\
\hline
Iterator<T> & Iterator<T> & MutableIterator<T> & (Mutable) Iterator<T>! \\
\hline
Iterable<T> & Iterable<T> & MutableIterable<T> & (Mutable) Iterable<T>! \\
\hline
Collection<T> & Collection<T> & MutableCollection<T> & (Mutable) Collection<T>! \\
\hline
Set<T> & Set<T> & MutableSet<T> & (Mutable) Set<T>! \\
\hline
List<T> & List<T> & MutableList<T> & (Mutable) List<T>! \\
\hline
ListIterator<T> & ListIterator<T> & MutableListIterator<T> & (Mutable) ListIterator<T>! \\
\hline
Map<K, V> & Map<K, V> & MutableMap<K, V> & (Mutable) Map<K, V>! \\
\hline
Map.Entry<K, V> & Map.Entry<K, V> & MutableMap.MutableEntry<K, V> & (Mutable) Map.(Mutable)Entry<K, V>
\end{tabular}
\end{center}

Semua kelas di atas berada dalam paket \texttt{kotlin.collections}.

Untuk larik sendiri, di Kotlin akan diterjemahkan sebagai berikut :

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Java} & \textbf{Kotlin} \\
\hline
int[] & kotlin.IntArray! \\
\hline
String[] & kotlin.Array<(out) String>! \\
\hline
\end{tabular}
\end{center}

\subsection{Java Generik}

Generik di Kotlin seperti pembahasan pada bagian \ref{secGenerik}, berbeda dengan kondisi generik di Java. Beberapa konversi yang dilakukan antara generik di Java dengan Kotlin adalah sebagai berikut :

\begin{itemize}
	\item \textit{Wildcard} di Java akan diterjemahkan berikut :
		\begin{itemize}
			\item \texttt{MyMethod<? extends Kelas>} menjadi \texttt{MyMethod<out Kelas!>!}.
			\item \texttt{MyMethod<? super Kelas>} menjadi \texttt{MyMethod<in Kelas!>!}
		\end{itemize}	
	\item Untuk tipe data mentah, yang biasanya tidak dideklarasikan akan menjadi seperti berikut :
		\begin{itemize}
			\item \texttt{ArrayList} menjadi \texttt{ArrayList<*>!}
		\end{itemize}
\end{itemize}

\subsection{Larik Java}

Untuk larik, ingatlah bahwa larik di Kotlin berbeda dengan larik di Java. Di Kotlin tidak diperbolehkan mengisikan data dari sub-kelas atau super-kelas, contohnya misalkan deklarasi yang disebutkan adalah \texttt{Array<Any>}, deklarasi tersebut tidak bisa diisikan dengan data seperti \texttt{Array<String>}. Dan untuk tipe data primitif di Java, ada kelas yang bertugas menangani masing-masing tipe data tersebut dalam larik seperti \texttt{IntArray}, \texttt{CharArray}, \texttt{FloatArray} dan seterusnya.

Gambaran kodenya akan terlihat seperti percobaan berikut, pertama kita buat dahulu kode dari Java dimana salah satu \textit{method} membutuhkan larik primitif \texttt{int} untuk di cetak ke layar monitor. Kode Javanya sebagai berikut :

\begin{lstlisting}
public class Pencetak {
	public void go(int[] data) {
		for(int i=0; i<data.length; i++) {
			System.out.println(data[i]);
		}
	}
}
\end{lstlisting}

Kode Kotlin yang menggunakan kelas \texttt{Pencetak} tersebut adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = intArrayOf(0,2,4,6)
	val pencetak = Pencetak()
	
	pencetak.go(data)
}
\end{lstlisting}

Hasil yang dikeluarkan oleh kode program di atas adalah sebagai berikut : 

\begin{lstlisting}
0
2
4
6
\end{lstlisting}

\subsection{Varargs di Java}

\textit{Varargs} di Java sebetulnya mirip dengan larik, hanya saja deklarasinya memiliki perbedaan dan lebih terlihat dinamis. Contoh berikut akan memberikan gambaran bahwa \textit{varargs} di Java dapat diakses dengan cara yang mirip dengan larik di Java apabila digunakan di dalam kode Kotlin. Berikut adalah kode dengan bahasa pemrograman Java yang memiliki parameter \textit{varargs} :

\begin{lstlisting}
public class Pencetak {
	public void go(int... data) {
		for(int i=0; i<data.length; i++) {
			System.out.println(data[i]);
		}
	}
}
\end{lstlisting}

Sedangkan kode di Kotlin untuk melakukan akses terhadap fungsi \texttt{go} dengan parameter \texttt{data} yang berupa \textit{varargs} adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = intArrayOf(0, 2, 4, 6)
	val pencetak = Pencetak()
	pencetak.go(*data)
}
\end{lstlisting}

Hasil keluarannya sama seperti kode sebelumnya, perbedaan yang dapat kita lihat ada pada baris ke-4, yaitu saat melakukan pemanggilan fungsi \texttt{go} dimana ada tanda bintang (\texttt{*}) pada parameter \texttt{data} yang diberikan.

\subsection{Pemeriksaan \textit{Exception}}

Di Kotlin, \textit{exception} tidak diperiksa terlebih dahulu, artinya, saat kita menggunakan \textit{method} di Java yang kemudian menghasilkan \textit{exception}, maka kita dapat abaikan saja, karena pada saat kompile dilakukan pun tidak ada peringatan kesalahan. 

Untuk lebih jelasnya, lihatlah kode berikut, kode pertama adalah kode Java yang menghasilkan \textit{exception}, berikut kodenya :

\begin{lstlisting}
public class Pencetak {
	public void go(int... data) throws Exception {
		if(data.length > 5) throw new Exception("Banyak Amat");
		
		for(int i=0; i<data.length; i++) {
			System.out.println(data[i]);
		}
	}
}
\end{lstlisting}

Dan kode Kotlin yang memanggil \textit{method} Java \texttt{go} tersebut akan membuat kesalahan dengan mengisikan 6 (enam) parameter seperti kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = intArrayOf(0, 2, 4, 6, 8, 10)
	val pencetak = Pencetak()	
	
	pencetak.go(*data)
}
\end{lstlisting}

Pada saat \textit{compile} dilakukan terhadap kode Kotlin tidak akan memunculkan masalah, tetapi begitu kita jalankan aplikasi Kotlin yang telah kita buat, maka baru akan muncul \textit{exception} yang dikembalikan oleh \textit{method} \texttt{go} dari kelas \texttt{Pencetak} di Java.

\subsection{\textit{Method} Kelas Objek di Java}

Pada saat kita mendeklarasikan kelas \texttt{Object} di Java, maka pada saat digunakan di Kotlin, kelas tersebut akan dikonversi ke kelas \texttt{Any} di Kotlin.

Kelas \texttt{Any} ini berbeda dengan kelas \texttt{Object} karena hanya memiliki 3 (tiga) \textit{method} saja, yaitu \texttt{toString()}, \texttt{hashCode()}, dan \texttt{equals()}. Untuk implementasi \textit{method} lain dari kelas \texttt{Object} maka perlu didefinisikan dengan \textit{fungsi ekstensi} seperti yang telah kita bahas sebelumnya.

\subsection{Mengakses \texttt{static}}

\textit{Static Member} di Java apabila digunakan di Kotlin akan dikonversi menjadi \textit{companion object} seperti penjelasan sebelumnya. Contoh kodenya adalah seperti berikut, kita akan ubah kode sebelumnya baik kode Java maupun kode di Kotlinnya, berikut adalah kode di Java yang kita ubah :

\begin{lstlisting}
public class Pencetak {
	public static void go(int... data) {
		for(int i=0; i<data.length; i++) {
			System.out.println(data[i]);
		}
	}
}
\end{lstlisting}

Kode di Kotlin yang akan menggunakan \textit{method static} di atas adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = intArrayOf(0, 2, 4, 6)
	
	Pencetak.go("data")
}
\end{lstlisting}

Hasilnya masih sama seperti di atas, yaitu akan mencetak seluruh angka yang ada dalam larik \texttt{data}. Yang berbeda adalah kita tidak perlu membuat instan baru seperti sebelumnya, namun langsung dapat dipanggil nama \textit{method}nya seperti pada baris ke-4.

\subsection{Java Reflection}

\subsection{Konversi SAM}

\subsection{Menggunakan JNI di Kotlin}

\section{Gunakan Kotlin di Java}