\chapter{Kelas dan Objek}

\section{Kelas}

Kelas di Kotlin dideklarasikan dengan kata kunci \texttt{class}. Contoh dalam kodenya adalah sebagai berikut :

\begin{lstlisting}
class Mahasiswa {
}
\end{lstlisting}

Deklarasi kelas memang sesederhana itu. Isi dari kelas itu sendiri terdiri dari konstruktor, properti atau yang biasa dikenal dengan istilah variabel, dan fungsi.

\subsection{Konstruktor}

Uniknya bentuk konstruktor dari Kotlin ini dibedakan menjadi 2 (dua), ada konstruktor utama, dan ada konstruktor tambahan. Kita bahas terlebih dahulu bagaimana bentuk dari konstruktor utama, contoh kode dasarnya adalah sebagai berikut :

\begin{lstlisting}
class Mahasiswa constructor(nama: String) {
}
\end{lstlisting}

Jika konstruktor tidak memiliki anotasi atau \textit{visibility modifiers}, maka kode di atas dapat disederhanakan menjadi seperti berikut :

\begin{lstlisting}
class Mahasiswa(nama: String) {
}
\end{lstlisting}

Tentang apa itu anotasi dan \textit{visibility modifiers} akan kita jelaskan di bab berikutnya. 

Lalu bagaimana cara memanfaatkan parameter yang ada pada konstruktor bila deklarasi konstruktor implisit seperti itu? Ada 2 (dua) cara, yang pertama melalui blok \texttt{init}, yang kedua dengan langsung mengisikan ke variabel yang bersangkutan. 

Berikut adalah contoh dari penggunaan blok \texttt{init} :

\begin{lstlisting}
fun main(args: Array<String>) {
	val mhs = Mahasiswa("tamami")
	
	println(mhs.nama)
}

class Mahasiswa(nama: String) {
	var nama: String
	
	init {
		this.nama = nama
	}
}
\end{lstlisting}

Pada baris ke-2 dari kode di atas, variabel \texttt{mhs} bertipe kelas \texttt{Mahasiswa} yang langsung dipanggil konstruktornya dengan parameter berupa teks (\textit{string}). 

Kotlin akan memanggil konstruktor utamanya kemudian menjalankan blok \texttt{init} untuk pertama kalinya. Isi dari blok \texttt{init} ini hanya mengisikan variabel \texttt{nama} dari parameter konstruktor \texttt{nama}.

Kemudian aplikasi menlanjutkan tugasnya untuk mencetak variabel \texttt{nama} milik instan kelas \texttt{Mahasiswa}.

Atau kita juga bisa persingkat kode di atas menjadi seperti berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val mhs = Mahasiswa("tamami")
	
	println(mhs.nama)
}

class Mahasiswa(nama: String) {
	var nama = nama
}
\end{lstlisting}

Hasil keluaran dari kode di atas sama persis dengan sebelumnya, seperti ini :

\begin{lstlisting}
tamami
\end{lstlisting}

Kita telah menghapus blok \texttt{init} dan melewatkan nilai dari parameter \texttt{nama} langsung ke variabel \texttt{nama}.

Lalu bagaimana dengan konstruktor tambahan, deklarasi nya ada di dalam tubuh kelas itu sendiri, contoh kodenya adalah seperti berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val mhs = Mahasiswa("tamami", "DIV-TI")
	
	println(mhs.nama)
	println(mhs.jurusan)
}

class Mahasiswa(nama: String) {
	var nama = nama
	var jurusan: String = ""
	
	constructor(nama: String, jurusan: String): this(nama) {
		this.jurusan = jurusan
	}
}
\end{lstlisting}

Deklarasi konstruktor utama ada di baris ke-8 dengan satu parameter yaitu \texttt{nama}, sedangkan deklarasi konstruktor tambahan ada pada baris ke-12 sampai dengan baris ke-14. Dimana konstruktor tambahan memiliki 2 (dua) parameter, yaitu \texttt{nama} dan \texttt{jurusan}. 

Ada satu tambahan lagi pada konstruktor tambahan, yaitu perintah \texttt{this} di akhir baris, ini karena Kotlin mengharuskan seluruh konstruktor tambahan memanggil konstruktor utama terlebih dahulu dengan perintah \texttt{this}.

Dalam sebuah kelas dapat memuat beberapa hal berikut :

\begin{itemize}
	\item Konstruktor dan blok \texttt{init}
	\item Fungsi
	\item Properti (atau lebih dikenal dengan variabel)
	\item Kelas bersarang
	\item Deklarasi Objek.
\end{itemize}

\subsection{Pewarisan}

Sebetulnya seluruh kelas di Kotlin akan bermuara pada kelas \texttt{Any} sebagai super-kelas-nya. Bahkan kelas-kelas yang deklarasinya tanpa super-kelas akan menjadikan kelas \texttt{Any} ini sebagai \textit{default}.

Untuk mendeklarasikan super kelas secara eksplisit, contoh kode berikut akan menjelaskannya :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai = Pejabat("tamami", "fungsional")
	
	println(pegawai.nama)
	println(pegawai.jabatan)
}

open class Pegawai(nama: String) {
	var nama = nama
}

class Pejabat(nama: String, jabatan: String): Pegawai(nama) {
	var jabatan = jabatan
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
tamami
fungsional
\end{lstlisting}

Pada kode di atas, yang menerangkan deklarasi super kelas secara eksplisit tepat pada baris ke-12, yang menunjukkan bahwa kelas \texttt{Pejabat} yang dibentuk adalah turunan dari kelas \texttt{Pegawai}.

Pada deklarasi kelas \texttt{Pegawai}, ada pernyataan \texttt{open} disana, ini sebetulnya menandakan bahwa kelas tersebut bukan bersifat final, karena secara \textit{default}, semua kelas yang dibentuk di Kotlin akan bersifat final, maka agar kita dapat membuat turunan dari kelas yang telah kita buat, maka kelas tersebut harus kita berikan tanda \texttt{open} di awal deklarasi kelas.

Alur dari kode program di atas dapat diceritakan demikian, pertama pada baris ke-2 kita membuat sebuah variabel bernama \texttt{pegawai}, kemudian diisikan dengan data dari instan kelas \texttt{Pejabat}.

Kita coba melompat ke baris 12, dimana ini adalah tempat deklarasi pembentukan kelas \texttt{Pejabat} yang memang memiliki 2 (dua) parameter. Namun pada baris ke-12 inilah secara eksplisit menyebutkan bahwa kelas \texttt{Pejabat} adalah turunan dari kelas \texttt{Pegawai}. Namun parameter yang dimasukan ke kelas \texttt{Pegawai} adalah parameter yang juga masuk melalui konstruktor \texttt{Pejabat}, sehingga parameter yang dilewatkan ke konstruktor \texttt{Pegawai} adalah parameter yang juga dibawah oleh konstruktor \texttt{Pejabat}.

Pemanggilan variabel atau properti dari kelas \texttt{Pejabat} di baris ke-4 dan ke-5 sebetulnya tidak aneh karena sebetulnya, setelah kelas \texttt{Pejabat} menjadi turunan dari kelas \texttt{Pegawai}, maka semua variabel dan fungsi yang ada pada kelas \texttt{Pegawai} akan dimiliki oleh kelas \texttt{Pejabat}, sehingga variabel dari kelas \texttt{Pegawai} dapat pula diakses dari kelas \texttt{Pejabat}.

Contoh lain untuk pewarisan dengan konstruktor tambahan bisa dilihat pada kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh pemanggilan konstruktor utama =-")
	val pegawai = Pejabat("tamami", "fungsional")
	println(pegawai.nama)
	println(pegawai.jabatan)
	
	println("\n-= contoh pemanggilan konstruktor tambahan =-")
	val pegawaiLain = Pejabat("19840409001", "tamami", "fungsional")
	println(pegawaiLain.nip)
	println(pegawaiLain.nama)
	println(pegawaiLain.jabatan)
}

open class Pegawai(nama: String) {
	var nama = nama
	var nip = ""
	
	constructor(nip: String, nama: String): this(nama) {
		this.nip = nip
	}
}

class Pejabat: Pegawai {
	var jabatan: String
	
	constructor(nama: String, jabatan: String): super(nama) {
		this.jabatan = jabatan
	}
	
	constructor(nip: String, nama: String, jabatan: String): super(nip, nama) {
		this.jabatan = jabatan
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
-= contoh pemanggilan konstruktor utama =-
tamami
fungsional

-= contoh pemanggilan konstruktor tambahan =- 
19840409001
tamami
fungsional
\end{lstlisting}

Pada kode di atas, kelas \texttt{Pegawai} memiliki 2 (dua) konstruktor, yang pertama adalah konstruktor utama dengan 1 (satu) buah parameter dengan nama \texttt{nama}, yang kedua adalah konstruktor dengan 2 (dua) parameter dengan nama \texttt{nip} dan \texttt{nama}.

Kita lihat bahwa pada konstruktor tambahan milik kelas \texttt{Pegawai} ada tambahan perintah \texttt{this} di belakang deklarasinya seperti yang telah dijelaskan pada saat cara mendeklarasikan konstruktor tambahan sebelumnya.

Kelas \texttt{Pejabat} merupakan turunan dari kelas \texttt{Pegawai} yang menggunakan 2 (dua) konstruktor dari kelas tersebut. Cara deklarasinya sama seperti konstruktor tambahan sebelumnya, hanya saja kali ini tidak menggunakan perintah \texttt{this} tetapi menggunakan kelas \texttt{super} karena yang dipanggil adalah super-kelas dari kelas \texttt{Pejabat} yaitu kelas \texttt{Pegawai}.

\subsection{\textit{Override} Fungsi}

Fungsi dalam bahasa objek biasa dikenal dengan istilah \textit{method}, mungkin akan digunakan secara bergantian istilah tersebut dalam buku ini yang artinya adalah sebetulnya sama.

Sama seperti kelas, untuk fungsi pun, agar dapat di \textit{override}, suatu fungsi harus dideklarasikan secara eksplisit dengan perintah \texttt{open}. Contoh kode untuk \textit{override} fungsi adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh kelas Pegawai =-")
	val pegawai = Pegawai("tamami")
	pegawai.cetak()
	
	println("\n-= contoh kelas Pejabat =-")
	val pegawaiLain = Pejabat("tamami", "fungsional")
	pegawaiLain.cetak()
}

open class Pegawai(nama: String) {
	var nama = nama
	
	open fun cetak() {
		println("nama : $nama")
	}
}

class Pejabat: Pegawai {
	var jabatan: String
	
	constructor(nama: String, jabatan: String): super(nama) {
		this.jabatan = jabatan
	}
	
	override fun cetak() {
		println("nama : $nama\njabatan : $jabatan");
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
-= contoh kelas Pegawai =-
nama : tamami

-= contoh kelas Pejabat =- 
nama : tamami
jabatan : fungsional
\end{lstlisting}

Yang menjadi titik fokus, fungsi yang akan di-\textit{override} harus diberikan perintah \texttt{open} seperti pada baris ke-14, dan pada saat akan meng-\textit{override} pada kelas turunannya, harus diberikan perintah \texttt{override}. 

Ini artinya fungsi \texttt{cetak} pada kelas \texttt{Pejabat} adalah fungsi turunan yang telah diadaptasikan sesuai kebutuhan kelas \texttt{Pejabat}, dan isi dari fungsi \textit{cetak} pada kelas \texttt{Pegawai} telah digantikan dengan yang baru, yaitu khusus untuk kelas \texttt{Pejabat}.

Sebagai catatan lain adalah bahwa apabila ada fungsi yang dapat di-\textit{override}maka deklarasi kelas juga harus memiliki perintah \texttt{open}, tidak boleh dalam kondisi final.

Fungsi-fungsi yang dideklarasikan secara \texttt{override}, akan otomatis menjadi \texttt{open} dan dapat di-\textit{override} pada kelas turunannya, untuk mencegah hal ini, dapat diberikan perintah \texttt{final} diawalnya, agar tidak dapat di-\textit{override} ulang.

Sebagai contoh, misalnya pada fungsi \texttt{cetak} milik kelas \texttt{Pejabat} tidak ingin agar kelas turunannya nanti melakukan \textit{override} terhadap fungsi ini, maka deklarasi yang mungkin adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh kelas Pegawai =-")
	val pegawai = Pegawai("tamami")
	pegawai.cetak()
	
	println("-= contoh kelas Pejabat =-")
	val pegawaiLain = Pejabat("tamami", "fungsional")
	pegawaiLain.cetak()
}

open class Pegawai(nama: String) {
	val nama = nama
	
	open fun cetak() {
		println("nama : $nama")
	}
}

class Pejabat: Pegawai {
	var jabatan: String
	
	constructor(nama: String, jabatan: String): super(nama) {
		this.jabatan = jabatan
	}
	
	final override fun cetak() {
		println("nama : $nama\njabatan : $jabatan")
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas sama saja dengan kode sebelumnya, hanya saja apabila kelas \texttt{Pejabat} memiliki turunan, maka turunannya tidak dapat melakukan \textit{override} terhadap fungsi \texttt{cetak}, karena telah dilakukan kuncian dengan perintah \texttt{final} pada baris ke-26.

\subsection{\textit{Override} variabel}

Variabel dalam bahasa objek biasa dikenal dengan istilah properti, jadi mungkin akan dibahas dalam buku ini bahwa properti adalah variabel milik kelas.

\textit{Override} variabel atau properti ini sama seperti \textit{override method}, ada penambahan perintah \texttt{open} pada properti yang dapat di-\textit{override} oleh kelas turunan, dan memberikan tambahan perintah \texttt{override} pada properti di kelas turunannya. Kodenya akan terlihat seperti berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh kelas Pegawai =-")
	val pegawai = Pegawai()
	pegawai.cetak()
	
	println("\n-= contoh kelas Pejabat =-")
	val pegawaiLain = Pejabat()
	pegawaiLain.cetak()
}

open class Pegawai {
	open var nama = "nama Pegawai"
	
	fun cetak() {
		println("nama : $nama")
	}
}

class Pejabat: Pegawai() {
	override var nama = "nama Pejabat"
}
\end{lstlisting}

Keluaran dari kode tersebut akan terlihat seperti ini :

\begin{lstlisting}
-= contoh kelas Pegawai =-
nama : nama Pegawai

-= contoh kelas Pejabat =-
nama : nama Pejabat
\end{lstlisting}

Seperti dijelaskan sebelumnya, bahwa agar properti dapat di-\textit{override}, maka perlu ditambahkan perintah \texttt{open} pada kelas utama seperti pada baris ke-12 dari kode di atas, kemudian menambahkan perintah \texttt{override} pada kelas turunannya seperti pada baris ke-20.

\subsection{\textit{Override rule}}

\textit{Override rule} ini terjadi karena kondisi dimana sebuah kelas diwajibkan melakukan \textit{override} atas suatu \textit{method} yang biasanya memiliki moyang 2 (dua) atau lebih kelas / \textit{interface}. Contoh kodenya adalah sebagai berikut : 

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh kelas Pegawai =-")
	val pegawai = Pegawai("tamami")
	pegawai.cetak()
	
	println(\n-= contoh kelas Pejabat =-"")
	val pejabat = Pejabat("tamami", "BPPKAD")
	pejabat.cetak()
}

open class Pegawai(nama: String) {
	var nama = nama
	
	open file cetak() {
		println("nama : $nama")
	}
}

interface Struktural {
	var unit: String
	
	fun cetak() {
		println("ini dicetak dari interface Struktural")
	}
}

class Pejabat(nama: String, unit: String): Pegawai(nama), Struktural {
	override var unit = unit
	
	override fun cetak() {
		println("nama : $nama\nunit : $unit")
	}
}
\end{lstlisting}

Hasil dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
-= contoh kelas Pegawai =-
nama : tamami

-= contoh kelas Pejabat =-
nama : tamami
unit : BPPKAD
\end{lstlisting}

Titik fokus untuk pembahasan kali ini ada pada baris ke-27, dimana kelas \texttt{Pejabat} mewarisi properti dan \textit{method} dari 1 (satu) kelas yaitu \texttt{Pegawai} dan 1 (satu) \textit{interface} \texttt{Struktural}. 

Kelas dan \textit{interface} tersebut memiliki 1 (satu) \textit{method} yang sama dengan nama \texttt{cetak}. Karena hal inilah kelas \texttt{Pejabat} dengan terpaksa harus melakukan \textit{override} untuk mendefinisikan bagaimana implementasi \textit{method} \texttt{cetak} pada kelas ini.

\section{Properti}

Deklarasi sebuah properti di Kotlin ada 2 (dua) cara, yaitu properti yang dapat diubah, dan properti yang hanya dapat dibaca saja. Untuk properti yang dapat diubah, perlu dideklarasikan dengan perintah \texttt{var} sedangkan untuk property yang hanya dapat diberikan nilai sekali dan tidak dapat berubah menggunakan kata perintah \texttt{val}.

Contohnya sudah banyak kita lakukan di atas, kita akan coba lagi dengan menggunakan 2 (dua) perintah tersebut, \texttt{var} dan \texttt{val}, berikut kodenya :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai()
	
	data.nama = "p. tamami"
	
	println(data.nama)
	println(data.nip)
}

class Pegawai {
	var nama = "tamami"
	val nip = "19840409001"
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
p. tamami
19840409001
\end{lstlisting}

Hal ini karena setelah pembentukan instan kelas \texttt{Pegawai} di baris ke-2, properti \texttt{nama} diubah kembali pada baris ke-4, sehingga nama yang barulah yang keluar di layar.

Hal yang sama tidak dapat dilakukan terhadap properti \texttt{nip}, karena properti \texttt{nip} tidak dapat diubah nilainya.

Secara lengkap, sebuah deklarasi properti akan dituliskan seperti format kode berikut :

\begin{lstlisting}
var <namaProperti>[: <tipeData>] [= <initializer>]
		[<getter>]
		[<setter>]
\end{lstlisting}

Penjelasannya adalah sebagai berikut :

\begin{itemize}
	\item \texttt{<namaProperti>} ini nantinya digantikan dengan nama properti
	\item \texttt{<tipeData>} ini akan digantikan dengan tipe data / nama kelas
	\item \texttt{<initializer>} adalah data awal yang akan diisikan ke dalam properti
	\item \texttt{<getter>} adalah kode untuk mengambil nilai dari properti
	\item \texttt{<setter>} adalah blok kode untuk memberikan nilai ke properti
\end{itemize}

Terlihat agak rumit, namun sebetulnya sederhana, seperti, \texttt{<getter>} dan \texttt{<setter>} sebetulnya opsional, boleh hadir, boleh tidak. Saat \texttt{<getter>} dan \texttt{<setter>} tidak hadir, maka sebetulnya Kotlin akan membuatkan kedua fungsi tersebut secara umum.

 \texttt{<tipeData>} pun sebetulnya bisa dijadikan implisit hanya dengan memberikan data awal pada bagian \texttt{<initializer>}. Mari kita coba contoh kode lebih lengkapnya untuk implementasi pembentukan properti seperti di atas, berikut adalah kodenya :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	
	println(data.nama)
}

class Pegawai(nama: String) {
	var nama: String = nama	
		get() = field
		set(nama) {
			field = nama
		}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
tamami
\end{lstlisting}

Kode yang kita maksud berada pada baris ke-8 sampai dengan baris ke-12, blok baris ini menerangkan detail bagaimana properti \texttt{nama}, apa tipe datanya, bagaimana cara mengisi nilainya dengan \texttt{set}, dan bagaimana mengambil datanya dengan \texttt{get}. Namun secara sederhana dengan tujuan yang sama, kode tersebut dapat diringkas menjadi seperti kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	
	println(data.nama)
}

class Pegawai(nama: String) {
	var nama = nama
}
\end{lstlisting}

Keluaran dari kode di atas pun sama, dapat kita lihat bahwa baris yang tadi dapat digantikan hanya dengan 1 (satu) baris saja, yaitu pada baris ke-8.

Di Kotlin, ada juga yang namanya konstanta, atau lebih tepatnya \textit{compile-time constants}, untuk menjadikan sebuah properti menjadi konstanta, diperlukan perintah \texttt{const}. 

Lalu apa bedanya dengan \texttt{val} yang nilainya juga tidak dapat diubah? Perbedaannya adalah, pada penggunaan \texttt{const}, properti ini hanya dapat dideklarasikan langsung di bawah kelas / objek, dan inisialisasinya hanya dapat dilakukan dengan nilai yang tipe datanya adalah \texttt{String} atau tipe data primitif.

Akan lebih jelas bila kita melihat kode program berikut sebagai contoh :

\begin{lstlisting}
val pegawai = Pegawai()
val nama = pegawai.namaLengkap()

fun main(args: Array<String>) {
	println(nama)
}

class Pegawai {
	fun namaLengkap(): String {
		return "p. tamami"
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
p. tamami
\end{lstlisting}

Pada penggunaan \texttt{val}, kita mungkin dapat menggunakan sebuah fungsi untuk mengisi nilainya seperti pada baris ke-2. Ini tidak mungkin dilakukan oleh properti dengan kata kunci \texttt{const}. Yang mungkin dilakukan apabila menggunakan kata kunci \texttt{const} adalah dengan kode berikut :

\begin{lstlisting}
const val nama = "P. Tamami"

fun main(args: Array<String>) {
	println(nama)
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
P. Tamami
\end{lstlisting}

Seperti pada penjelasan sebelumnya bahwa konstanta ini hanya dapat diberikan nilainya langsung dengan tipe data berupa String atau tipe data primitif lainnya, dan tidak dapat diubah pada saat \textit{runtime}.

\section{\textit{Interface}}

\textit{Interface} disini bukan tampilan jendela atau tatap muka sebuah aplikasi, tetapi \textit{interface} disini adalah bentuk implementasi dari orientasi objek. 

\textit{Interface} di Kotlin bukan hanya dapat menyiapkan kerangka berupa \textit{method}, tetapi diperbolehkan melakukan implementasi di dalam \textit{method} tersebut. Pada \textit{interface} boleh terdapat properti / atribut hanya saja harus bersifat abstrak atau tanpa isi, karena implementasi isi akan dideklarasikan langsung dalam kelas turunannya.

Contoh penggunaan \textit{interface} adalah seperti kode berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pejabat("tamami")
	
	println(data.getNamaLengkap())
}

interface Pegawai {
	fun getNamaLengkap(): String
}

class Pejabat(nama: String): String {
	var nama: String = nama
	
	override fun getNamaLengkap(): String {
		return "Pa/Bu $nama"
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
Pa/Bu tamami
\end{lstlisting}

Kita lihat bagaimana \textit{interface} \texttt{Pegawai} pada baris ke-7 sampai dengan baris ke-9 membentuk sebuah kerangka implementasi tentang Pegawai dan kelas \texttt{Pejabat} melakukan pewarisan dan mengimplementasikan fungsi \texttt{getNamaLengkap()} seperti pada baris ke-14 sampai dengan baris ke-16.

\section{\textit{Visibility Modifiers}}

\textit{Visibility Modifiers} di Kotlin ada 4 (empat) macam, yaitu : \texttt{public}, \texttt{private}, \texttt{protected}, dan \texttt{internal}. Secara \textit{default} bila tidak ada deklarasi lain, maka yang terpilih adalah \texttt{public}.

Penjelasannya adalah sebagai berikut :

\begin{itemize}
	\item \texttt{public}, artinya deklarasi akan dapat diakses dari manapun
	\item \texttt{private}, artinya hanya sebatas file yang mendeklarasikan
	\item \texttt{internal}, artinya dapat diakses oleh objek-objek yang berada pada modul yang sama
	\item \texttt{protected} artinya sapa seperti \texttt{private}, tetapi dapat terlihat pada kelas turunannya.
\end{itemize}

Penjelasan untuk \texttt{public} tidak perlu kita lakukan kembali, karena dari contoh-contoh sebelumnya kita sudah mendapati lingkup \texttt{public} itu demikian, dapat diakses dari manapun, dan secara \textit{default} deklarasi tiap properti atau fungsi akan berada pada lingkup \texttt{public}.

Untuk \texttt{private}, contoh kodenya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	println(data.nama)
}

class Pegawai(nama: String) {
	private var nama: String = nama
}
\end{lstlisting}

Kode di atas tidak akan pernah bisa di-\textit{compile} karena kesalahan bahwa pada baris ke-7, deklarasi properti \texttt{nama} memiliki lingkup \texttt{private} sehingga perintah pada baris ke-3 tidak akan pernah dapat dieksekusi.

Sekarang kita coba untuk implementasi dengan kata kunci \texttt{internal}, buatlah 2 (dua) buah \textit{file}, isi dari \textit{file} kode sumber pertama adalah sebagai berikut :

\begin{lstlisting}
public class Pegawai(nama: String) {
	internal var nama = nama
}
\end{lstlisting}

Lalu \textit{file} yang kedua, isi kodenya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	println(data.nama)
}
\end{lstlisting}

Yang pertama dilakukan kompilasi adalah \textit{file} dengan nama kelas \texttt{Pegawai}, misal saya beri nama \texttt{Pegawai.kt}, lalu coba \textit{compile} dengan perintah berikut :

\begin{lstlisting}
kotlinc Pegawai.kt
\end{lstlisting}

Namun pada saat \textit{compile file} yang ke-2, karena saya beri nama \textit{file} yang kedua dengan \texttt{Test.kt}, lakukan seperti kode / perintah berikut :

\begin{lstlisting}
kotlinc -cp . Test.kt
\end{lstlisting}

Saat \textit{compile} akan muncul peringatan kesalahan bahwa deklarasi \texttt{nama} pada kelas \texttt{Pegawai} bersifat \texttt{internal} sehingga tidak dapat dilakukan pemanggilan di \textit{method} \texttt{main}.

Untuk percobaan \texttt{protected}, perhatikan kode berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pejabat("tamami")
	println(data.getNamaLengkap())
}

open class Pegawai(nama: String) {
	protected var nama = nama
}

class Pejabat(nama: String): Pegawai(nama) {
	fun getNamaLengkap(): String {
		return "pa/bu $nama"
	}
}
\end{lstlisting}

Pada baris ke-7 kode di atas, ada deklarasi \texttt{protected}, artinya pada baris ke-3 kita tidak dapat memanggil langsung dengan perintah \texttt{data.nama}. 

Kemudian di baris ke-10 sampai dengan ke-14, ada deklarasi kelas \texttt{Pejabat} yang mewarisi atribut dan fungsi dari kelas \texttt{Pegawai}, yang diwarisi tentu saja adalah atribut \texttt{nama}, maka dari itu, pemanggilan atribut \texttt{nama} masih dapat dilakukan pada kelas \texttt{Pejabat} tanpa harus mendeklarasikan atribut ini karena atribut \texttt{nama} ini adalah hasil dari pewarisan kelas \texttt{Pegawai}.

\section{Ekstensi Fungsi}

Kotlin memeberikan kita sebuah fasilitas ekstensi fungsi. Artinya tanpa harus melakukan pewarisan, kita dapat menambahkan beberapa fungsi di luar deklarasi kelas. Mari kita lihat contoh kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	data.cetakNama()
}

fun Pegawai.cetakNama() {
	println("pa/bu ${this.nama}")
}

open class Pegawai(nama: String) {
	var nama = nama
}
\end{lstlisting}

Hasil dari kode di atas adalah seperti berikut ini :

\begin{lstlisting}
pa/bu tamami
\end{lstlisting}

Kita lihat pada blok deklarasi kelas \texttt{Pegawai} pada baris ke-10 sampai dengan baris ke-12, tidak ada fungsi dengan nama \texttt{cetakNama()}, tambahan fungsi tersebut muncul di luar kelas, yaitu pada baris ke-6 sampai dengan baris ke-8, sehingga memungkinkan perintah pada baris ke-3 dilaksanakan.

Kondisi ekstensi fungsi ini sebetulnya tidak menambahkan anggota baru ke dalam kelas, tetapi memungkinkan sebuah variabel untuk dipanggil dengan fungsi yang belum ada pada dirinya. Untuk membuktikan bahwa ekstensi fungsi tidak sama dengan fungsi kelas yang asli, perhatikan kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var pejabat = Pejabat()
	
	cetakIsinya(pejabat)
}

fun Pegawai.cetak() = "ini kelar Pegawai"

fun Pejabat.cetak() = "ini kelas Pejabat"

fun cetakIsinya(pegawai: Pegawai) {
	println(pegawai.cetak())
}

open class Pegawai

class Pejabat: Pegawai()
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
ini kelas Pegawai
\end{lstlisting}

Terlihat bahwa pada saat dilewatkan instan dari kelas \texttt{Pejabat} pada baris ke-4, seharusnya yang tercetak adalah \texttt{ini kelas Pejabat}, namun yang keluar justru sebaliknya, ini karena yang dipanggil dalam fungsi \texttt{cetakIsinya} adalah extensi fungsi \texttt{cetak} yang dideklarasikan menempel pada kelas \texttt{Pegawai}, sehingga walaupun sebenarnya kelas \texttt{Pejabat} mewarisi fungsi dan \textit{method} dari kelas Pegawai, tapi perlakuannya bahwa fungsi \texttt{cetak} tidak ikut diwariskan, melainkan dipanggil fungsi ekstensi aslinya, yaitu \texttt{Pegawai.cetak()}.

Jika kita ingin mengakses ekstensi fungsi dari luar paket, caranya adalah dengan melakukan \texttt{import}, contohnya dapat kita lihat pada kode berikut dengan 2 (dua) \textit{file} yang berbeda paket.

\textit{File} pertama akan mendeklarasikan kelas \texttt{Pegawai}, yang berada di paket \texttt{entity}, berikut adalah kodenya :

\begin{lstlisting}
package entity

public class Pegawai() {
	internal var nama: String = ""
}

fun Pegawai.cetakInfo() {
	println("ini cetakInfo dari Pegawai")
}
\end{lstlisting}

Setelah file tersebut di\textit{compile}, \textit{file} hasil kompilasi akan berada pada \textit{folder} \texttt{entity} dengan 2 (dua) \textit{file} berekstensi \texttt{.class}. 

Hasil dari 2 (dua) \textit{file} tersebut bila nama \textit{file}-nya adalah \texttt{Pegawai.kt}, akan menjadi \texttt{PegawaiKt.class} dan \texttt{Pegawai.class}. Sebetulnya \textit{file} \texttt{Pegawai.class} berisi kelas \texttt{Pegawai}, sedangkan \textit{file} \texttt{PegawaiKt.class} berisi fungsi yang dideklarasikan di luar kelas \texttt{Pegawai} namun masih dalam satu \textit{file} \texttt{Pegawai.kt}.

Lalu \textit{file} yang ke-2 isinya adalah sebagai berikut :

\begin{lstlisting}
import entity.Pegawai
import entity.cetakInfo

fun main(args Array<String>) {
	var pegawai = Pegawai()
	pegawai.cetakInfo()
}
\end{lstlisting}

Pada saat melakukan \textit{compile} terhadap \textit{file} yang ke-2, anggaplah kita berikan \textit{file} ini nama \texttt{Test.kt}. Untuk memberikan petunjuk bagi Kotlin bahwa pustaka yang akan kita gunakan (kelas \texttt{Pegawai}) berada pada paket \texttt{entity}, maka kita arahkan Kotlin agar mengerti dengan opsi perintah \texttt{classpath}. Berikut perintah lengkap yang dapat dieksekusi :

\begin{lstlisting}
> kotlinc -cp . Test.kt
\end{lstlisting}

Pada saat menjalankan aplikasi tersebut, maka hasil keluaran yang tampak di layar adalah seperti berikut ini :

\begin{lstlisting}
ini cetakInfo dari Pegawai
\end{lstlisting}

Yang perlu di perhatikan adalah pada \textit{file} \texttt{Test.kt} pada baris ke-2. Untuk dapat menggunakan ekstensi fungsi yang berada di luar paket, maka diperlukan deklarasi \texttt{import} seperti pada baris ke-2. 

Bagaimana deklarasi untuk ekstensi fungsi apabila berada di dalam kelas yang lain, bukan langsung di bawah paket tertentu. Untuk memahami ini, kita akan coba awali dari kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	Pelanggan.eksekusi(Barang())
}

class Barang {
	fun cetakInfo() {
		println("ini dari kelas Barang")
	}
}

class Pelanggan {
	fun cetakInfo() {
		println("ini dari kelas Pelanggan")
	}
	
	fun Barang.cetakAll() {
		cetakInfo()
		this@Pelanggan.cetakInfo()
	}
	
	fun eksekusi(barang: Barang) {
		barang.cetakAll()
	}
}
\end{lstlisting}

Hasil dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
ini dari kelas Barang
ini dari kelas Pelanggan
\end{lstlisting}

Alur programnya sebetulnya adalah seperti ini, pada saat pemanggilan fungsi \texttt{eksekusi} milik kelas \texttt{Pelanggan} di baris ke-2, program akan loncat ke baris 21 dan memanggil ekstensi fungsi \texttt{cetakAll} milik kelas \texttt{Barang} yang berada di dalam kelas \texttt{Pelanggan} di baris ke-16.

Pada saat eksekusi baris ke-17, yang dipanggil adalah fungsi \texttt{cetakInfo} milik kelas \texttt{Barang} yang berada di baris ke-6, sehingga tercetaklah lebih dahulu teks \texttt{ini dari kelas Barang}.

Yang terakhir karena fungsi \texttt{cetakInfo} milik kelas \texttt{Pelanggan} dan kelas \texttt{Barang} memiliki bentuk yang sama, maka pada baris ke-18 diperjelas dengan \texttt{this@Pelanggan}, sehingga tercetaklah seperti pada baris ke-2 hasil keluaran program.

Bila fungsi yang dipanggil memiliki nama atau bentuk yang berbeda, tidak perlu ditegaskan dengan perintah \texttt{this@Pelanggan}.

\section{Kelas Data}

Ada saatnya dimana kita membuat sebuah kelas dengan tujuan spesifik yaitu menjadi tempat simpanan data. Di Kotlin, kelas ini ditandai dengan perintah \texttt{data}, berikut contohnya :

\begin{lstlisting}
data class Pegawai(var nip: String, var nama: String, var gaji: Int)
\end{lstlisting}

Kelas di atas sebetulnya akan membuat beberapa fungsi secara otomatis seperti berikut :

\begin{itemize}
	\item Fungsi \texttt{equals} yang fungsinya untuk melakukan pemeriksaan apakah kedua objek yang dibandingkan sama isinya.
	\item Fungsi \texttt{hashCode} yang fungsinya untuk menghasilkan kode \textit{hash} yang memastikan bahwa tiap objek yang terbentuk bersifat unik.
	\item Fungsi \texttt{toString} yang akan mencetak nama kelas beserta parameternya.
	\item Fungsi \texttt{componentN} sesuai jumlah parameter yang hadir di konstruktor.
	\item Fungsi \texttt{copy} yang akan memberikan duplikasi data untuk instan kelas lain yang terbentuk.
\end{itemize}

Coba kita buktikan, apakah benar semua fungsi itu terbentuk secara otomatis, seharusnya saat fungsi tersebut terbentuk otomatis, dapat langsung dipanggil pada instan kelas yang terbentuk, berikut kode lengkap pembuktiannya :

\begin{lstlisting}
data class Pegawai(var nip: String, var nama: String, var gaji: Int) 

fun main(args: Array<String>) {
	var pegawai = Pegawai("1984001", "tamami", 3000)
	
	println("hashCode = ${pegawai.hashCode()}")
	println("toString = ${pegawai.toString()}")
	println("comp1 = ${pegawai.component1()}")
	println("comp2 = ${pegawai.component2()}")
	println("comp3 = ${pegawai.component3()}")
	
	var pegawai2 = pegawai.copy(nip = "1984002", nama = "ami")
	println("data pegawai2 = ${pegawai2.toString()}")
	
	var pegawaiSama = pegawai.copy()
	println("pegawai sama dengan pegawaiSama ga? ${pegawai.equals(pegawaiSama)}")
	println("pegawai sama dengan pegawai2 ga? ${pegawai.equals(pegawai2)}")
}
\end{lstlisting}

Hasil dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
hashCode = 337043080
toString = Pegawai(nip=1984001, nama=tamami, gaji=3000)
comp1 = 1984001
comp2 = tamami
comp3 = 3000
data pegawai2 = Pegawai(nip=1984002, nama=ami, gaji=3000)
pegawai sama dengan pegawai pegawaiSama ga? true
pegawai sama dengan pegawai pegawai2 ga? false
\end{lstlisting}

Ternyata terbukti bahwa semua fungsi di atas terbentuk otomatis pada kelas data. Yang menarik adalah pada baris ke-7 dan ke-8 dari hasil keluaran, terlihat bahwa apabila data dari tiap parameter sama persis, maka 2 (dua) kelas yang dibandingkan akan dianggap sama karena isinya sama.

Adat yang biasanya terjadi untuk menjaga konsistensi kode program terkait kelas data ini adalah sebagai berikut : 

\begin{itemize}
	\item Konstruktor utama harus menyediakan paling sedikit 1 (satu) parameter
	\item Parameter yang hadir di konstruktor harus diberi tanda \texttt{var} atau \texttt{val}
	\item Kelas data tidak boleh memiliki kata kunci \texttt{abstract}, \texttt{open}, \texttt{sealed}, atau \texttt{inner}.
\end{itemize}

\section{Kelas Tertutup}

Penggunaan kelas tertutup ini sangat spesifik, yaitu membantu kita melakukan seleksi \texttt{when} dengan lebih sempurna. Artinya, pada saat aplikasi melakukan seleksi, jangan sampai ada 1 (satu) opsi atau lebih yang tertinggal tanpa sebuah pemeriksaan.

Akan lebih jelas apabila kita melihat contoh kodenya seperti berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val angka1 = Positif(4)
	val angka2 = Negatif(-20)
	val angka3 = Nihil()
	
	print("angka1 : ")
	println(cek(angka1))
	
	print("angka2 : ")
	println(cek(angka2))
	
	print("angka3 : ")
	println(cek(angka3))
}

fun cek(data: Cek): String = when(data) {
	is Positif -> "${data.angka} : bilangan positif"
	is Negatif -> "${data.angka} : bilangan negatif"
	is Nihil -> "0"
}

sealed class Cek

class Positif(val angka: Int): Cek()

class Negatif(val angka: Int): Cek()

class Nihil: Cek()
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
angka1 : 4 : bilangan positif
angka2 : -20 : bilangan negatif
angka3 : 0
\end{lstlisting}

Terlihat bahwa deklarasi \textit{sealed class} \texttt{Cek} ada di baris ke-22, diikuti dengan deklarasi sub-kelas dari \texttt{Cek}. Ada 3 (tiga) kelas yang mewarisi kelas \texttt{Cek} ini.

Fungsi dari \texttt{sealed class} secara spesifik akan bermanfaat bila dihubungkan dengan deklarasi \texttt{when} pada baris ke-16.

Kita akan coba melihat alur dari kode program yang telah kita buat, pertama, kita siapkan beberapa variabel / properti / atribut seperti terlihat di baris ke-2 sampai dengan baris ke-4.

Kemudian melakukan pencetakan ke layar monitor dengan memanggil fungsi \texttt{cek} untuk masing-masing variabel yang sudah disiapkan, seperti terlihat di baris ke-7, baris ke-10, dan baris ke-13.

Kekuatan \texttt{sealed class} sebetulnya ada di sini, yaitu dibaris ke-16, dengan adanya perintah \texttt{when} dengan variabel \texttt{data} yang menjadi objek seleksi, maka akan diperiksa tipe data dari variabel \texttt{data} ini terhadap seluruh sub-kelas dari \texttt{sealed class Cek}, apakah \texttt{Positif}, \texttt{Negatif}, atau \texttt{Nihil}.

Apabila salah satu baris dihilangkan di antara baris ke-17 sampai dengan baris ke-19, maka saat \textit{compile} akan muncul peringatan bahwa masih ada perintah seleksi yang tertinggal, harap deklarasikan atau ganti dengan deklarasi \texttt{else}.

Misal, pada baris ke-19, kita hapus, maka akan ada peringatan bahwa perintah \texttt{is Nihil} tidak ada dan harus dideklarasikan.

\section{Generik}

Seperti bahasa pemrograman Java, Kotlin pun memiliki fasilitas generik yang memungkinkan deklarasi atas tipe data dibuat umum. Biasanya akan kita temukan di pustaka \textit{collection}. Coba perhatikan contoh kode berikut untuk implementasi generik :

\begin{lstlisting}
import java.util.ArrayList

fun main(args: Array<String>) {
	var data = Data(2)
	data.addData(5)
	
	data.cetak()
}

class Data<T>(t: T) {
	var larik = ArrayList<T>()
	
	init {
		larik.add(t)
	}
	
	fun addData(t: T) {
		larik.add(t)
	}
	
	fun cetak() {
		for(data in larik) {
			println(data)
		}
	}
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
2
5
\end{lstlisting}

Deklarasi generik sebetulnya ada pada baris ke-10, yaitu dengan tanda seperti ini \texttt{<T>}, yang artinya, kelas \texttt{Data} yang kita buat dapat menerima tipe data apapun untuk disimpan dalam properti \texttt{larik} yang sudah disediakan.

Pada contoh kita di atas, kita menggunakan kelas \texttt{Data} dengan tipe data \texttt{Int} sebagai pengganti \texttt{T}. Sehingga \texttt{ArrayList} yang dideklarasikan pada baris ke-11 akan digunakan hanya untuk tipe data \texttt{Int}.

\section{Kelas Bersarang}

Artinya di dalam sebuah kelas, bisa diperbolehkan kita membentuk kelas lain, dimana kelas yang berada di dalam ini dapat mengakses variabel yang berada pada kelas di atasnya. Contoh kodenya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = Pegawai().Jabatan()
	
	data.cetak()
}

class Pegawai {
	var nama = "tamami"
	
	inner class Jabatan {
		fun cetak() {
			println("$nama sebagai direktur")
		}
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas akan terlihat seperti berikut ini :

\begin{lstlisting}
tamami sebagai Direktur
\end{lstlisting}

Kita lihat bahwa kelas \texttt{Jabatan} bersarang atau berada di dalam kelas \texttt{Pegawai} pada baris ke-10 dengan kode \texttt{inner} di depannya yang memungkinkan di dalam kelas \texttt{Jabatan} memanggil properti milik kelas induknya. Apabila kata kunci \texttt{inner} kita hilangkan, maka pemanggilan variabel \texttt{\$nama} pada baris ke-12 tidak akan mengalami kegagalan kompilasi.

Ada saatnya sebuah kelas dibentuk tanpa memerlukan nama instan seperti di Java, istilahnya biasa dikenal dengan \textit{anonymous class}, di Kotlin implementasinya seperti kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai(object: Jabatan() {
		init {
			jabatan = "direktur"
		}
	})
	
	println(data.jabatan.jabatan)
}

class Pegawai(jabatan: Jabatan) {
	var jabatan = jabatan
}

open class Jabatan {
	var jabatan = ""
}
\end{lstlisting}

Hasil dari kode di atas akan terlihat seperti berikut ini :

\begin{lstlisting}
direktur
\end{lstlisting}

Deklarasi dari \textit{anonymous class} pada kode di atas ada pada baris ke-2 dengan kata kunci \texttt{object}. Kelas Jabatan sendiri harus di deklarasikan dengan kata kunci \texttt{open} seperti pada baris ke-15 agar kelas anonim yang terbentuk di baris ke-2 dapat diubah sesuai kebutuhan. Hasilnya adalah mengisikan variabel \texttt{jabatan} dengan teks \texttt{direktur}.

\section{Kelas \textit{Enum}}

Kelas \textit{enum} sendiri sebetulnya ditujukan untuk membentuk definisi data baru yang bisa disamakan dengan konstanta. Kita lihat contoh kode berikut untuk lebih jelasnya :

\begin{lstlisting}
fun main(args: Array<String>) {
	var jenisKelamin = Kelamin.PRIA
	
	println(jenisKelamin)
}

enum class Kelamin {
	PRIA, WANITA
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
PRIA
\end{lstlisting}

Hasil keluaran yang ditampilkan bukan berupa \texttt{String}, tetapi berupa nama \textit{enum}nya, masing-masing konstanta \textit{enum} dipisahkan menggunakan tanda koma.

Sebetulnya tiap konstanta dalam kelas \textit{enum} adalah sebuah objek atau lebih tepatnya adalah instan dari kelas \textit{enum}nya, dan tiap objek ini dapat dilakukan inisialisasi. Berikut contoh kodenya :

\begin{lstlisting}
fun main(args: Array<String>) {
	var angka = Angka.SEPULUH
	
	println(angka)
	when(Angka.SATU.nilai >= Angka.SEPULUH.nilai) {
		true -> println("Satu lebih besar dari Sepuluh")
		false -> println("Sepuluh lebih besar dari Satu")
	}
}

enum class Angka(val nilai: Int) {
	SATU(1),
	SEPULUH(10),
	SERATUS(100)
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
SEPULUH
Sepuluh lebih besar dari Satu
\end{lstlisting}

Pada baris ke-2, kita melihat bahwa variabel \texttt{angka} diisikan dengan data \textit{enum} berupa \texttt{Angka.SEPULUH}, kemudian mencetaknya pada baris ke-4.

Pada baris ke-5, kita mencoba melakukan perbandingan, apakah data \textit{enum} \texttt{SATU} lebih besar atau sama dengan data \textit{enum} \texttt{SEPULUH}, namun ternyata hasilnya adalah \texttt{false} sehingga yang tercetak ke layar adalah perintah \texttt{println} pada baris ke-7.

Perhatikan pada baris ke-5 bahwa yang dilakukan perbandingan adalah parameter \texttt{nilai} yang ada pada tiap-tiap \textit{enum} konstantanya.

Satu lagi dari \textit{enum} di Kotlin adalah bahwa tiap \textit{enum} konstantanya memiliki properti yang memberikan kita informasi nama (\texttt{name}) dan posisi (\texttt{ordinal}) urutan deklarasinya dalam kelas \textit{enum}. Perhatikan kode berikut untuk memperjelasnya :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = Angka.SEPULUH
	
	println("namanya ${data.name}")
	println("urutan ${data.ordinal}")
}

enum class Angka(val nilai: Int) {
	SATU(1),
	SEPULUH(10),
	SERATUS(100)
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
namanya SEPULUH
urutan 1
\end{lstlisting}

Kita lihat bahwa nama dari \textit{enum} konstanta \texttt{SEPULUH} adalah \texttt{SEPULUH} juga, sedangkan urutan deklarasinya adalah \texttt{1} (satu), dimana data urutan awal yang digunakan dalam \textit{enum} ini adalah 0 (nol).

\section{Objek Ekspresi dan Deklarasi}

Ada kalanya saat kita ingin menggunakan dan mengubah sebuah kelas, namun tidak ingin dengan cara membuat sub-kelas baru, melainkan melakukannya dengan cara membuat kelas anonim, saat inilah objek ekspresi dan objek deklarasi dapat digunakan. Coba perhatikan kode berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai(object : Bio() {
		override fun cetakNama() {
			println("nama : $nama")
			println("hp : $hp")
		}
	})
	
	data.bio.cetakNama()
}

class Pegawai(bio: Bio) {
	var bio = bio
}

abstract class Bio {
	val nama = "tamami"
	val hp = "08123456"
	
	abstract fun cetakNama()
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
nama : tamami
hp : 08123456
\end{lstlisting}

Deklarasi objek ekspresi ada pada baris ke-2, yaitu membuat instan dari kelas \texttt{Bio} dengan langsung merubah implementasinya sekaligus tanpa membuat sub-kelas terlebih dahulu.

Untuk objek deklarasi, penjelasannya kita awali dari kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	println(Rumus.tambah(2,5))
}

object Rumus {
	fun tambah(a: Int, b: Int): Int {
		return a + b
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
7
\end{lstlisting}

Object deklarasi ada pada baris ke-5 sampai dengan baris ke-9, cara memanggil objek deklarasi ini mirip dengan pemanggilan tipe \texttt{static} di Java, langsung memanggil nama objek dan nama fungsi yang dibutuhkan tanpa harus membuat instan dari kelasnya.

Untuk penggunaan objek deklarasi di dalam kelas, harus ditambahkan kata kunci \texttt{companion}. Berikut adalah contoh kodenya :

\begin{lstlisting}
fun main(args: Array<String>) {
	println(Pegawai.ambilSandi(2,3))
}

class Pegawai {
	companion object Sandi {
		fun ambilSandi(a: Int, b: Int): Int {
			return a * b - a
		}
	}
}
\end{lstlisting}

Hasil keluaran dari kode tersebut adalah sebagai berikut :

\begin{lstlisting}
4
\end{lstlisting}

Perhatikan cara pemanggilan fungsi \texttt{ambilSandi} pada baris ke-2 yang juga tanpa harus membuat instan dari kelas \texttt{Pegawai} dan tanpa menyertakan pemanggilan nama objeknya, \texttt{Sandi}.

\section{Delegasi}

Pola delegasi telah terbukti dapat menjadi alternatif implementasi pewarisan \textit{interface}, dan Kotlin menyediakannya secara \textit{native}. Mari kita perhatikan contoh kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val data = Honda()
	Proses(data).cetakInfo()
}

interface Mobil {
	fun cetakInfo()
}

class Honda(): Mobil {
	override fun cetakInfo() {
		println("Ini implementasi mobil Honda")
	}
}

class Proses(mobil: Mobil): Mobil by mobil
\end{lstlisting}

Hasil keluaran yang muncul adalah sebagai berikut :

\begin{lstlisting}
Ini implementasi mobil Honda
\end{lstlisting}

Kita lihat bahwa kelas \texttt{Honda} mewarisi \textit{interface} \texttt{Mobil}, kemudian melakukan \texttt{override} pada fungsi \texttt{cetakInfo}.

Kemudian ada kelas \texttt{Proses} yang pada konstruktornya memiliki 1 (satu) parameter, yaitu \texttt{Mobil}, deklarasi kelas \texttt{Proses} ini pun mewarisi \textit{interface} \texttt{Mobil}, tetapi dengan kata kunci \texttt{by}. 

Maksud dari penggunaan kata kunci \texttt{by} ini sebetulnya yaitu bahwa \textit{method} implementasi yang berada di kelas \texttt{Proses} ini, yang diwariskan dari \textit{interface} \texttt{Mobil}, akan bergantung pada nilai yang dilewatkan melalui parameter \texttt{mobil} pada konstruktor.

Contoh lebih jelas dapat dilihat pada kode program berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Honda()
	Proses(data).cetakInfo()
	
	var dataLain = Toyota()
	Proses(dataLain).cetakInfo()
}

interface Mobil {
	fun cetakInfo()
}

class Honda(): Mobil {
	override fun cetakInfo() {
		println("Ini implementasi mobil Honda")
	}
}

class Toyota(): Mobil {
	override fun cetakInfo() {
		println("Ini implementasi mobil Toyota")
	}
}

class Proses(mobil: Mobil): Mobil by mobil
\end{lstlisting}

Mirip seperti percobaan sebelumnya, kali ini kita memiliki 2 (dua) kelas yang mewarisi \textit{interface} \texttt{Mobil}, dan masing-masing kelas memiliki implementasi fungsi \texttt{cetakInfo} masing-masing.

Kita lihat pada saat pemanggilan kelas \texttt{Proses} dengan parameter yang berbeda pada baris ke-3 dan baris ke-6, akan menghasilkan fungsi \texttt{cetakInfo} yang berbeda pula.

\section{Mendelegasikan Properti}

Tadi adalah delegasi yang terjadi pada tingkat kelas, untuk tingkat properti pun telah disiapkan oleh Kotlin. Contoh dasarnya dapat dilihat pada kode berikut :

\begin{lstlisting}
import kotlin.reflect.KProperty

fun main(args: Array<String>) {
	var data: String by GSData()
	
	data = "tamami"
	println("cetak $data")
}

class GSData {
	var data: Any? = ""

	operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
		return "nama properti : ${property.name} isinya $data"
	}
	
	operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
		println("nilai $value sudah disimpan di ${property.name}")
		data = value
	}
}
\end{lstlisting}

Hasil keluaran untuk kode di atas adalah sebagai berikut :

\begin{lstlisting}
nilai tamami sudah di simpan di data
cetak nama properti : data isinya tamami
\end{lstlisting}

Padahal operasi yang terjadi adalah sederhana, namun karena implementasi \texttt{String} untuk variabel \texttt{data} telah didelegasikan ke kelas \texttt{GSData}, maka ada perubahan yang terjadi. 

Perubahan yang pertama adalah pada saat properti \texttt{data} diisikan sebuah nilai, yaitu \texttt{tamami}, seperti pada baris ke-6, maka fungsi yang bekerja untuk menangani ini adalah fungsi \texttt{setValue} milik kelas \texttt{GSData}.

Ada 2 (dua) aktifitas yang dilakukan di fungsi \texttt{setValue}, yang pertama adalah mencetak informasi ke layar bahwa nilai dari parameter \texttt{\$value} sudah disimpan. Kemudian menyimpan nilai dari \texttt{value} ke variabel atau properti \texttt{data} milik kelas \texttt{GSData}.

Saat inilah dicetak ke monitor informasi teks yang berbunyi \texttt{nilai tamami sudah di simpan di data}. Yang pada kondisi ini, data teks \texttt{tamami} telah diisikan ke properti \texttt{data}.

Perubahan berikutnya adalah pada saat melakukan akses data terhadap properti \texttt{data} seperti pada baris ke-7.

Pada baris ke-7, seharusnya hanya mencetak teks \texttt{cetak \$data} dimana \texttt{\$data} akan digantikan oleh nilainya, namun pada kenyataannya tidak demikian, yang terjadi adalah mencetak kalimat \texttt{cetak nama properti : data isinya tamami}, kata \texttt{cetak} disana sebetulnya memang isi dari baris ke-7, sedangkan sisanya adalah nilai yang dikembalikan dari fungsi \texttt{getValue} milik kelas \texttt{GSData}.

Ada beberapa delegasi properti yang umum yang mungkin dapat digunakan nantinya, yaitu :

\begin{itemize}
	\item \texttt{lazy}
	\item \texttt{observable}
	\item \texttt{map}
\end{itemize}

\subsection{\texttt{lazy}}

\texttt{lazy} ini sebetulnya adalah fungsi hasil implementasi dari \textit{interface} \texttt{Lazy} yang hanya berlaku untuk deklarasi \texttt{val}, nantinya operasi yang terjadi hanya akan terjadi sekali saja, kemudian nilai akhir yang dihasilkan akan disimpan, dan dibaca berulang saat ada pemanggilan atau akses terhadap properti ini. 

Coba kita perhatikan contoh kode berikut :

\begin{lstlisting}
val lazyVar: String by lazy {
	println("init")
	"tamami"
}

fun main(args: Array<String>) {
	println(lazyVar)
	println(lazyVar)
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
init
tamami
tamami
\end{lstlisting}

Kenapa hasilnya demikian? padahal pada baris ke-7 dan baris ke-8, akses terhadap \texttt{lazyVar} dilakukan 2 (dua) kali, tetapi proses pencetakan \texttt{init} hanya sekali.

Hal tersebut karena sifat dari \texttt{lazy} ini hanya melakukan prosesnya sekali di awal akses, kemudian nilainya disimpan untuk akses selanjutnya. 

Jadi pada saat melakukan akses \texttt{lazyVar} di baris ke-7, delegasi propertinya akan melakukan secara lengkap, mulai dari proses mencetak teks \texttt{init}, hingga mengembalikan nilai teks \texttt{tamami}. 

Namun pada saat melakukan akses \texttt{lazyVar} di baris ke-8, delegasi properti hanya akan mengembalikan nilai teks \texttt{tamami} saja.

\subsection{\texttt{observable}}

Untuk menggunakan delegasi properti \texttt{observable}, kita harus melakukan \textit{import} terlebih dahulu terhadap kelas \texttt{kotlin.properties.Delegates}.

Delegasi properti \texttt{observable} ini membutuhkan 2 (dua) parameter, yang pertama adalah nilai awal, yang kedua adalah parameter untuk melakukan tugas perubahan data. Parameter kedua inilah yang akan dipanggil berulang-ulang apabila ada perubahan data.

Sebetulnya parameter kedua dari \texttt{observable} ini akan dieksekusi setelah pengisian data pada variabel / properti terjadi.

Pada parameter ke-2 ini, memiliki 3 (tiga) parameter di dalamnya, yaitu properti yang diisikan nilainya, nilai lama, dan nilai baru. Untuk lebih jelasnya coba perhatikan kode berikut :

\begin{lstlisting}
import kotlin.properties.Delegates

var nama: String by Delegates.observable("[kosong]") {
	properti, lama, baru -> 
		println("properti ${properti.name} telah berubah dari $lama ke $baru")
}

fun main(args: Array<String>) {
	nama = "tamami"
	nama = "ami"
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
properti nama telah berubah dari [kosong] ke tamami
properti nama telah berubah dari tamami ke ami
\end{lstlisting}

Pada awalnya, nilai yang diberikan ke properti \texttt{nama} adalah teks \texttt{"[kosong]"}, kemudian pada saat ada perubahan atau pengisian data di baris ke-9, maka parameter ke-2 dari \texttt{observable} yaitu bagian yang menangani perubahan data akan dijalankan. 

Beberapa parameter dari bagian yang menangani perubahan ini akan terisi, dimana \texttt{properti} adalah bagian properti yang dideklarasikan dengan kata kunci \texttt{observable}, kemudian \texttt{lama} akan diisikan dengan data sebelumnya, yaitu teks \texttt{[kosong]}, dan \texttt{baru} akan diisikan dengan data yang telah diisikan, yaitu teks \texttt{tamami}. 

Selanjutnya akan mencetak informasi sebagaimana baris ke-1 dari hasil keluaran di atas.

Pada saat perubahan data kedua, yaitu pada baris ke-10, isi dari parameter \texttt{properti} tentunya tetap, sedangkan isi dari parameter \texttt{lama} akan berubah menjadi teks \texttt{tamami} dan isi parameter \texttt{baru} akan menjadi teks \texttt{ami}.

Setelah itu akan dicetak keluaran dengan hasil sebagaimana baris ke-2 dari hasil keluaran di atas.

\subsection{\texttt{map}}

Penggunaan \texttt{Map} sebagai delegasi properti sebetulnya memanfaatkan \texttt{Map} sebagai parameter konstruktor atau fungsi yang biasanya diimplementasikan pada pencacah kode JSON atau hal yang berhubungan dengan data dinamis. Mari kita perhatikan contoh kode program berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai = Pegawai(mapOf(
		"nama" to "tamami",
		"gaji" to 10000
	))
	
	println(pegawai.nama)
	println(pegawai.gaji)
}

class Pegawai(val map: Map<String, Any?>) {
	val nama: String by map
	val gaji: Long by map
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
tamami
10000
\end{lstlisting}

Parameter deklarasi kelas \texttt{Pegawai} hanya membutuhkan sebuah parameter saja seperti pada baris ke-11. Nantinya, isi dari \texttt{map} tersebut akan dipetakan otomatis dimana \texttt{key}-nya adalah nama properti dan \texttt{value}-nya adalah isi dari propertinya.

Sehingga pada saat properti diakses seperti pada baris ke-7 dan baris ke-8, akan ditampilkan nilai dari masing-masing propertinya.