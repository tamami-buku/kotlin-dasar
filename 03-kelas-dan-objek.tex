\chapter{Kelas dan Objek}

\section{Kelas}

Kelas di Kotlin dideklarasikan dengan kata kunci \texttt{class}. Contoh dalam kodenya adalah sebagai berikut :

\begin{lstlisting}
class Mahasiswa {
}
\end{lstlisting}

Deklarasi kelas memang sesederhana itu. Isi dari kelas itu sendiri terdiri dari konstruktor, properti atau yang biasa dikenal dengan istilah variabel, dan fungsi.

\subsection{Konstruktor}

Uniknya bentuk konstruktor dari Kotlin ini dibedakan menjadi 2 (dua), ada konstruktor utama, dan ada konstruktor tambahan. Kita bahas terlebih dahulu bagaimana bentuk dari konstruktor utama, contoh kode dasarnya adalah sebagai berikut :

\begin{lstlisting}
class Mahasiswa constructor(nama: String) {
}
\end{lstlisting}

Jika konstruktor tidak memiliki anotasi atau \textit{visibility modifiers}, maka kode di atas dapat disederhanakan menjadi seperti berikut :

\begin{lstlisting}
class Mahasiswa(nama: String) {
}
\end{lstlisting}

Tentang apa itu anotasi dan \textit{visibility modifiers} akan kita jelaskan di bab berikutnya. 

Lalu bagaimana cara memanfaatkan parameter yang ada pada konstruktor bila deklarasi konstruktor implisit seperti itu? Ada 2 (dua) cara, yang pertama melalui blok \texttt{init}, yang kedua dengan langsung mengisikan ke variabel yang bersangkutan. 

Berikut adalah contoh dari penggunaan blok \texttt{init} :

\begin{lstlisting}
fun main(args: Array<String>) {
	val mhs = Mahasiswa("tamami")
	
	println(mhs.nama)
}

class Mahasiswa(nama: String) {
	var nama: String
	
	init {
		this.nama = nama
	}
}
\end{lstlisting}

Pada baris ke-2 dari kode di atas, variabel \texttt{mhs} bertipe kelas \texttt{Mahasiswa} yang langsung dipanggil konstruktornya dengan parameter berupa teks (\textit{string}). 

Kotlin akan memanggil konstruktor utamanya kemudian menjalankan blok \texttt{init} untuk pertama kalinya. Isi dari blok \texttt{init} ini hanya mengisikan variabel \texttt{nama} dari parameter konstruktor \texttt{nama}.

Kemudian aplikasi menlanjutkan tugasnya untuk mencetak variabel \texttt{nama} milik instan kelas \texttt{Mahasiswa}.

Atau kita juga bisa persingkat kode di atas menjadi seperti berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val mhs = Mahasiswa("tamami")
	
	println(mhs.nama)
}

class Mahasiswa(nama: String) {
	var nama = nama
}
\end{lstlisting}

Hasil keluaran dari kode di atas sama persis dengan sebelumnya, seperti ini :

\begin{lstlisting}
tamami
\end{lstlisting}

Kita telah menghapus blok \texttt{init} dan melewatkan nilai dari parameter \texttt{nama} langsung ke variabel \texttt{nama}.

Lalu bagaimana dengan konstruktor tambahan, deklarasi nya ada di dalam tubuh kelas itu sendiri, contoh kodenya adalah seperti berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val mhs = Mahasiswa("tamami", "DIV-TI")
	
	println(mhs.nama)
	println(mhs.jurusan)
}

class Mahasiswa(nama: String) {
	var nama = nama
	var jurusan: String = ""
	
	constructor(nama: String, jurusan: String): this(nama) {
		this.jurusan = jurusan
	}
}
\end{lstlisting}

Deklarasi konstruktor utama ada di baris ke-8 dengan satu parameter yaitu \texttt{nama}, sedangkan deklarasi konstruktor tambahan ada pada baris ke-12 sampai dengan baris ke-14. Dimana konstruktor tambahan memiliki 2 (dua) parameter, yaitu \texttt{nama} dan \texttt{jurusan}. 

Ada satu tambahan lagi pada konstruktor tambahan, yaitu perintah \texttt{this} di akhir baris, ini karena Kotlin mengharuskan seluruh konstruktor tambahan memanggil konstruktor utama terlebih dahulu dengan perintah \texttt{this}.

Dalam sebuah kelas dapat memuat beberapa hal berikut :

\begin{itemize}
	\item Konstruktor dan blok \texttt{init}
	\item Fungsi
	\item Properti (atau lebih dikenal dengan variabel)
	\item Kelas bersarang
	\item Deklarasi Objek.
\end{itemize}

\subsection{Pewarisan}

Sebetulnya seluruh kelas di Kotlin akan bermuara pada kelas \texttt{Any} sebagai super-kelas-nya. Bahkan kelas-kelas yang deklarasinya tanpa super-kelas akan menjadikan kelas \texttt{Any} ini sebagai \textit{default}.

Untuk mendeklarasikan super kelas secara eksplisit, contoh kode berikut akan menjelaskannya :

\begin{lstlisting}
fun main(args: Array<String>) {
	val pegawai = Pejabat("tamami", "fungsional")
	
	println(pegawai.nama)
	println(pegawai.jabatan)
}

open class Pegawai(nama: String) {
	var nama = nama
}

class Pejabat(nama: String, jabatan: String): Pegawai(nama) {
	var jabatan = jabatan
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
tamami
fungsional
\end{lstlisting}

Pada kode di atas, yang menerangkan deklarasi super kelas secara eksplisit tepat pada baris ke-12, yang menunjukkan bahwa kelas \texttt{Pejabat} yang dibentuk adalah turunan dari kelas \texttt{Pegawai}.

Pada deklarasi kelas \texttt{Pegawai}, ada pernyataan \texttt{open} disana, ini sebetulnya menandakan bahwa kelas tersebut bukan bersifat final, karena secara \textit{default}, semua kelas yang dibentuk di Kotlin akan bersifat final, maka agar kita dapat membuat turunan dari kelas yang telah kita buat, maka kelas tersebut harus kita berikan tanda \texttt{open} di awal deklarasi kelas.

Alur dari kode program di atas dapat diceritakan demikian, pertama pada baris ke-2 kita membuat sebuah variabel bernama \texttt{pegawai}, kemudian diisikan dengan data dari instan kelas \texttt{Pejabat}.

Kita coba melompat ke baris 12, dimana ini adalah tempat deklarasi pembentukan kelas \texttt{Pejabat} yang memang memiliki 2 (dua) parameter. Namun pada baris ke-12 inilah secara eksplisit menyebutkan bahwa kelas \texttt{Pejabat} adalah turunan dari kelas \texttt{Pegawai}. Namun parameter yang dimasukan ke kelas \texttt{Pegawai} adalah parameter yang juga masuk melalui konstruktor \texttt{Pejabat}, sehingga parameter yang dilewatkan ke konstruktor \texttt{Pegawai} adalah parameter yang juga dibawah oleh konstruktor \texttt{Pejabat}.

Pemanggilan variabel atau properti dari kelas \texttt{Pejabat} di baris ke-4 dan ke-5 sebetulnya tidak aneh karena sebetulnya, setelah kelas \texttt{Pejabat} menjadi turunan dari kelas \texttt{Pegawai}, maka semua variabel dan fungsi yang ada pada kelas \texttt{Pegawai} akan dimiliki oleh kelas \texttt{Pejabat}, sehingga variabel dari kelas \texttt{Pegawai} dapat pula diakses dari kelas \texttt{Pejabat}.

Contoh lain untuk pewarisan dengan konstruktor tambahan bisa dilihat pada kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh pemanggilan konstruktor utama =-")
	val pegawai = Pejabat("tamami", "fungsional")
	println(pegawai.nama)
	println(pegawai.jabatan)
	
	println("\n-= contoh pemanggilan konstruktor tambahan =-")
	val pegawaiLain = Pejabat("19840409001", "tamami", "fungsional")
	println(pegawaiLain.nip)
	println(pegawaiLain.nama)
	println(pegawaiLain.jabatan)
}

open class Pegawai(nama: String) {
	var nama = nama
	var nip = ""
	
	constructor(nip: String, nama: String): this(nama) {
		this.nip = nip
	}
}

class Pejabat: Pegawai {
	var jabatan: String
	
	constructor(nama: String, jabatan: String): super(nama) {
		this.jabatan = jabatan
	}
	
	constructor(nip: String, nama: String, jabatan: String): super(nip, nama) {
		this.jabatan = jabatan
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
-= contoh pemanggilan konstruktor utama =-
tamami
fungsional

-= contoh pemanggilan konstruktor tambahan =- 
19840409001
tamami
fungsional
\end{lstlisting}

Pada kode di atas, kelas \texttt{Pegawai} memiliki 2 (dua) konstruktor, yang pertama adalah konstruktor utama dengan 1 (satu) buah parameter dengan nama \texttt{nama}, yang kedua adalah konstruktor dengan 2 (dua) parameter dengan nama \texttt{nip} dan \texttt{nama}.

Kita lihat bahwa pada konstruktor tambahan milik kelas \texttt{Pegawai} ada tambahan perintah \texttt{this} di belakang deklarasinya seperti yang telah dijelaskan pada saat cara mendeklarasikan konstruktor tambahan sebelumnya.

Kelas \texttt{Pejabat} merupakan turunan dari kelas \texttt{Pegawai} yang menggunakan 2 (dua) konstruktor dari kelas tersebut. Cara deklarasinya sama seperti konstruktor tambahan sebelumnya, hanya saja kali ini tidak menggunakan perintah \texttt{this} tetapi menggunakan kelas \texttt{super} karena yang dipanggil adalah super-kelas dari kelas \texttt{Pejabat} yaitu kelas \texttt{Pegawai}.

\subsection{\textit{Override} Fungsi}

Fungsi dalam bahasa objek biasa dikenal dengan istilah \textit{method}, mungkin akan digunakan secara bergantian istilah tersebut dalam buku ini yang artinya adalah sebetulnya sama.

Sama seperti kelas, untuk fungsi pun, agar dapat di \textit{override}, suatu fungsi harus dideklarasikan secara eksplisit dengan perintah \texttt{open}. Contoh kode untuk \textit{override} fungsi adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh kelas Pegawai =-")
	val pegawai = Pegawai("tamami")
	pegawai.cetak()
	
	println("\n-= contoh kelas Pejabat =-")
	val pegawaiLain = Pejabat("tamami", "fungsional")
	pegawaiLain.cetak()
}

open class Pegawai(nama: String) {
	var nama = nama
	
	open fun cetak() {
		println("nama : $nama")
	}
}

class Pejabat: Pegawai {
	var jabatan: String
	
	constructor(nama: String, jabatan: String): super(nama) {
		this.jabatan = jabatan
	}
	
	override fun cetak() {
		println("nama : $nama\njabatan : $jabatan");
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
-= contoh kelas Pegawai =-
nama : tamami

-= contoh kelas Pejabat =- 
nama : tamami
jabatan : fungsional
\end{lstlisting}

Yang menjadi titik fokus, fungsi yang akan di-\textit{override} harus diberikan perintah \texttt{open} seperti pada baris ke-14, dan pada saat akan meng-\textit{override} pada kelas turunannya, harus diberikan perintah \texttt{override}. 

Ini artinya fungsi \texttt{cetak} pada kelas \texttt{Pejabat} adalah fungsi turunan yang telah diadaptasikan sesuai kebutuhan kelas \texttt{Pejabat}, dan isi dari fungsi \textit{cetak} pada kelas \texttt{Pegawai} telah digantikan dengan yang baru, yaitu khusus untuk kelas \texttt{Pejabat}.

Sebagai catatan lain adalah bahwa apabila ada fungsi yang dapat di-\textit{override}maka deklarasi kelas juga harus memiliki perintah \texttt{open}, tidak boleh dalam kondisi final.

Fungsi-fungsi yang dideklarasikan secara \texttt{override}, akan otomatis menjadi \texttt{open} dan dapat di-\textit{override} pada kelas turunannya, untuk mencegah hal ini, dapat diberikan perintah \texttt{final} diawalnya, agar tidak dapat di-\textit{override} ulang.

Sebagai contoh, misalnya pada fungsi \texttt{cetak} milik kelas \texttt{Pejabat} tidak ingin agar kelas turunannya nanti melakukan \textit{override} terhadap fungsi ini, maka deklarasi yang mungkin adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh kelas Pegawai =-")
	val pegawai = Pegawai("tamami")
	pegawai.cetak()
	
	println("-= contoh kelas Pejabat =-")
	val pegawaiLain = Pejabat("tamami", "fungsional")
	pegawaiLain.cetak()
}

open class Pegawai(nama: String) {
	val nama = nama
	
	open fun cetak() {
		println("nama : $nama")
	}
}

class Pejabat: Pegawai {
	var jabatan: String
	
	constructor(nama: String, jabatan: String): super(nama) {
		this.jabatan = jabatan
	}
	
	final override fun cetak() {
		println("nama : $nama\njabatan : $jabatan")
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas sama saja dengan kode sebelumnya, hanya saja apabila kelas \texttt{Pejabat} memiliki turunan, maka turunannya tidak dapat melakukan \textit{override} terhadap fungsi \texttt{cetak}, karena telah dilakukan kuncian dengan perintah \texttt{final} pada baris ke-26.

\subsection{\textit{Override} variabel}

Variabel dalam bahasa objek biasa dikenal dengan istilah properti, jadi mungkin akan dibahas dalam buku ini bahwa properti adalah variabel milik kelas.

\textit{Override} variabel atau properti ini sama seperti \textit{override method}, ada penambahan perintah \texttt{open} pada properti yang dapat di-\textit{override} oleh kelas turunan, dan memberikan tambahan perintah \texttt{override} pada properti di kelas turunannya. Kodenya akan terlihat seperti berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh kelas Pegawai =-")
	val pegawai = Pegawai()
	pegawai.cetak()
	
	println("\n-= contoh kelas Pejabat =-")
	val pegawaiLain = Pejabat()
	pegawaiLain.cetak()
}

open class Pegawai {
	open var nama = "nama Pegawai"
	
	fun cetak() {
		println("nama : $nama")
	}
}

class Pejabat: Pegawai() {
	override var nama = "nama Pejabat"
}
\end{lstlisting}

Keluaran dari kode tersebut akan terlihat seperti ini :

\begin{lstlisting}
-= contoh kelas Pegawai =-
nama : nama Pegawai

-= contoh kelas Pejabat =-
nama : nama Pejabat
\end{lstlisting}

Seperti dijelaskan sebelumnya, bahwa agar properti dapat di-\textit{override}, maka perlu ditambahkan perintah \texttt{open} pada kelas utama seperti pada baris ke-12 dari kode di atas, kemudian menambahkan perintah \texttt{override} pada kelas turunannya seperti pada baris ke-20.

\subsection{\textit{Override rule}}

\textit{Override rule} ini terjadi karena kondisi dimana sebuah kelas diwajibkan melakukan \textit{override} atas suatu \textit{method} yang biasanya memiliki moyang 2 (dua) atau lebih kelas / \textit{interface}. Contoh kodenya adalah sebagai berikut : 

\begin{lstlisting}
fun main(args: Array<String>) {
	println("-= contoh kelas Pegawai =-")
	val pegawai = Pegawai("tamami")
	pegawai.cetak()
	
	println(\n-= contoh kelas Pejabat =-"")
	val pejabat = Pejabat("tamami", "BPPKAD")
	pejabat.cetak()
}

open class Pegawai(nama: String) {
	var nama = nama
	
	open file cetak() {
		println("nama : $nama")
	}
}

interface Struktural {
	var unit: String
	
	fun cetak() {
		println("ini dicetak dari interface Struktural")
	}
}

class Pejabat(nama: String, unit: String): Pegawai(nama), Struktural {
	override var unit = unit
	
	override fun cetak() {
		println("nama : $nama\nunit : $unit")
	}
}
\end{lstlisting}

Hasil dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
-= contoh kelas Pegawai =-
nama : tamami

-= contoh kelas Pejabat =-
nama : tamami
unit : BPPKAD
\end{lstlisting}

Titik fokus untuk pembahasan kali ini ada pada baris ke-27, dimana kelas \texttt{Pejabat} mewarisi properti dan \textit{method} dari 1 (satu) kelas yaitu \texttt{Pegawai} dan 1 (satu) \textit{interface} \texttt{Struktural}. 

Kelas dan \textit{interface} tersebut memiliki 1 (satu) \textit{method} yang sama dengan nama \texttt{cetak}. Karena hal inilah kelas \texttt{Pejabat} dengan terpaksa harus melakukan \textit{override} untuk mendefinisikan bagaimana implementasi \textit{method} \texttt{cetak} pada kelas ini.

\section{Properti}

Deklarasi sebuah properti di Kotlin ada 2 (dua) cara, yaitu properti yang dapat diubah, dan properti yang hanya dapat dibaca saja. Untuk properti yang dapat diubah, perlu dideklarasikan dengan perintah \texttt{var} sedangkan untuk property yang hanya dapat diberikan nilai sekali dan tidak dapat berubah menggunakan kata perintah \texttt{val}.

Contohnya sudah banyak kita lakukan di atas, kita akan coba lagi dengan menggunakan 2 (dua) perintah tersebut, \texttt{var} dan \texttt{val}, berikut kodenya :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai()
	
	data.nama = "p. tamami"
	
	println(data.nama)
	println(data.nip)
}

class Pegawai {
	var nama = "tamami"
	val nip = "19840409001"
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
p. tamami
19840409001
\end{lstlisting}

Hal ini karena setelah pembentukan instan kelas \texttt{Pegawai} di baris ke-2, properti \texttt{nama} diubah kembali pada baris ke-4, sehingga nama yang barulah yang keluar di layar.

Hal yang sama tidak dapat dilakukan terhadap properti \texttt{nip}, karena properti \texttt{nip} tidak dapat diubah nilainya.

Secara lengkap, sebuah deklarasi properti akan dituliskan seperti format kode berikut :

\begin{lstlisting}
var <namaProperti>[: <tipeData>] [= <initializer>]
		[<getter>]
		[<setter>]
\end{lstlisting}

Penjelasannya adalah sebagai berikut :

\begin{itemize}
	\item \texttt{<namaProperti>} ini nantinya digantikan dengan nama properti
	\item \texttt{<tipeData>} ini akan digantikan dengan tipe data / nama kelas
	\item \texttt{<initializer>} adalah data awal yang akan diisikan ke dalam properti
	\item \texttt{<getter>} adalah kode untuk mengambil nilai dari properti
	\item \texttt{<setter>} adalah blok kode untuk memberikan nilai ke properti
\end{itemize}

Terlihat agak rumit, namun sebetulnya sederhana, seperti, \texttt{<getter>} dan \texttt{<setter>} sebetulnya opsional, boleh hadir, boleh tidak. Saat \texttt{<getter>} dan \texttt{<setter>} tidak hadir, maka sebetulnya Kotlin akan membuatkan kedua fungsi tersebut secara umum.

 \texttt{<tipeData>} pun sebetulnya bisa dijadikan implisit hanya dengan memberikan data awal pada bagian \texttt{<initializer>}. Mari kita coba contoh kode lebih lengkapnya untuk implementasi pembentukan properti seperti di atas, berikut adalah kodenya :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	
	println(data.nama)
}

class Pegawai(nama: String) {
	var nama: String = nama	
		get() = field
		set(nama) {
			field = nama
		}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
tamami
\end{lstlisting}

Kode yang kita maksud berada pada baris ke-8 sampai dengan baris ke-12, blok baris ini menerangkan detail bagaimana properti \texttt{nama}, apa tipe datanya, bagaimana cara mengisi nilainya dengan \texttt{set}, dan bagaimana mengambil datanya dengan \texttt{get}. Namun secara sederhana dengan tujuan yang sama, kode tersebut dapat diringkas menjadi seperti kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	
	println(data.nama)
}

class Pegawai(nama: String) {
	var nama = nama
}
\end{lstlisting}

Keluaran dari kode di atas pun sama, dapat kita lihat bahwa baris yang tadi dapat digantikan hanya dengan 1 (satu) baris saja, yaitu pada baris ke-8.

Di Kotlin, ada juga yang namanya konstanta, atau lebih tepatnya \textit{compile-time constants}, untuk menjadikan sebuah properti menjadi konstanta, diperlukan perintah \texttt{const}. 

Lalu apa bedanya dengan \texttt{val} yang nilainya juga tidak dapat diubah? Perbedaannya adalah, pada penggunaan \texttt{const}, properti ini hanya dapat dideklarasikan langsung di bawah kelas / objek, dan inisialisasinya hanya dapat dilakukan dengan nilai yang tipe datanya adalah \texttt{String} atau tipe data primitif.

Akan lebih jelas bila kita melihat kode program berikut sebagai contoh :

\begin{lstlisting}
val pegawai = Pegawai()
val nama = pegawai.namaLengkap()

fun main(args: Array<String>) {
	println(nama)
}

class Pegawai {
	fun namaLengkap(): String {
		return "p. tamami"
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
p. tamami
\end{lstlisting}

Pada penggunaan \texttt{val}, kita mungkin dapat menggunakan sebuah fungsi untuk mengisi nilainya seperti pada baris ke-2. Ini tidak mungkin dilakukan oleh properti dengan kata kunci \texttt{const}. Yang mungkin dilakukan apabila menggunakan kata kunci \texttt{const} adalah dengan kode berikut :

\begin{lstlisting}
const val nama = "P. Tamami"

fun main(args: Array<String>) {
	println(nama)
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
P. Tamami
\end{lstlisting}

Seperti pada penjelasan sebelumnya bahwa konstanta ini hanya dapat diberikan nilainya langsung dengan tipe data berupa String atau tipe data primitif lainnya, dan tidak dapat diubah pada saat \textit{runtime}.

\section{\textit{Interface}}

\textit{Interface} disini bukan tampilan jendela atau tatap muka sebuah aplikasi, tetapi \textit{interface} disini adalah bentuk implementasi dari orientasi objek. 

\textit{Interface} di Kotlin bukan hanya dapat menyiapkan kerangka berupa \textit{method}, tetapi diperbolehkan melakukan implementasi di dalam \textit{method} tersebut. Pada \textit{interface} boleh terdapat properti / atribut hanya saja harus bersifat abstrak atau tanpa isi, karena implementasi isi akan dideklarasikan langsung dalam kelas turunannya.

Contoh penggunaan \textit{interface} adalah seperti kode berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pejabat("tamami")
	
	println(data.getNamaLengkap())
}

interface Pegawai {
	fun getNamaLengkap(): String
}

class Pejabat(nama: String): String {
	var nama: String = nama
	
	override fun getNamaLengkap(): String {
		return "Pa/Bu $nama"
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
Pa/Bu tamami
\end{lstlisting}

Kita lihat bagaimana \textit{interface} \texttt{Pegawai} pada baris ke-7 sampai dengan baris ke-9 membentuk sebuah kerangka implementasi tentang Pegawai dan kelas \texttt{Pejabat} melakukan pewarisan dan mengimplementasikan fungsi \texttt{getNamaLengkap()} seperti pada baris ke-14 sampai dengan baris ke-16.

\section{\textit{Visibility Modifiers}}

\textit{Visibility Modifiers} di Kotlin ada 4 (empat) macam, yaitu : \texttt{public}, \texttt{private}, \texttt{protected}, dan \texttt{internal}. Secara \textit{default} bila tidak ada deklarasi lain, maka yang terpilih adalah \texttt{public}.

Penjelasannya adalah sebagai berikut :

\begin{itemize}
	\item \texttt{public}, artinya deklarasi akan dapat diakses dari manapun
	\item \texttt{private}, artinya hanya sebatas file yang mendeklarasikan
	\item \texttt{internal}, artinya dapat diakses oleh objek-objek yang berada pada modul yang sama
	\item \texttt{protected} artinya sapa seperti \texttt{private}, tetapi dapat terlihat pada kelas turunannya.
\end{itemize}

Penjelasan untuk \texttt{public} tidak perlu kita lakukan kembali, karena dari contoh-contoh sebelumnya kita sudah mendapati lingkup \texttt{public} itu demikian, dapat diakses dari manapun, dan secara \textit{default} deklarasi tiap properti atau fungsi akan berada pada lingkup \texttt{public}.

Untuk \texttt{private}, contoh kodenya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	println(data.nama)
}

class Pegawai(nama: String) {
	private var nama: String = nama
}
\end{lstlisting}

Kode di atas tidak akan pernah bisa di-\textit{compile} karena kesalahan bahwa pada baris ke-7, deklarasi properti \texttt{nama} memiliki lingkup \texttt{private} sehingga perintah pada baris ke-3 tidak akan pernah dapat dieksekusi.

Sekarang kita coba untuk implementasi dengan kata kunci \texttt{internal}, buatlah 2 (dua) buah \textit{file}, isi dari \textit{file} kode sumber pertama adalah sebagai berikut :

\begin{lstlisting}
public class Pegawai(nama: String) {
	internal var nama = nama
}
\end{lstlisting}

Lalu \textit{file} yang kedua, isi kodenya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pegawai("tamami")
	println(data.nama)
}
\end{lstlisting}

Yang pertama dilakukan kompilasi adalah \textit{file} dengan nama kelas \texttt{Pegawai}, misal saya beri nama \texttt{Pegawai.kt}, lalu coba \textit{compile} dengan perintah berikut :

\begin{lstlisting}
kotlinc Pegawai.kt
\end{lstlisting}

Namun pada saat \textit{compile file} yang ke-2, karena saya beri nama \textit{file} yang kedua dengan \texttt{Test.kt}, lakukan seperti kode / perintah berikut :

\begin{lstlisting}
kotlinc -cp . Test.kt
\end{lstlisting}

Saat \textit{compile} akan muncul peringatan kesalahan bahwa deklarasi \texttt{nama} pada kelas \texttt{Pegawai} bersifat \texttt{internal} sehingga tidak dapat dilakukan pemanggilan di \textit{method} \texttt{main}.

Untuk percobaan \texttt{protected}, perhatikan kode berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	var data = Pejabat("tamami")
	println(data.getNamaLengkap())
}

open class Pegawai(nama: String) {
	protected var nama = nama
}

class Pejabat(nama: String): Pegawai(nama) {
	fun getNamaLengkap(): String {
		return "pa/bu $nama"
	}
}
\end{lstlisting}

Pada baris ke-7 kode di atas, ada deklarasi \texttt{protected}, artinya pada baris ke-3 kita tidak dapat memanggil langsung dengan perintah \texttt{data.nama}. 

Kemudian di baris ke-10 sampai dengan ke-14, ada deklarasi kelas \texttt{Pejabat} yang mewarisi atribut dan fungsi dari kelas \texttt{Pegawai}, yang diwarisi tentu saja adalah atribut \texttt{nama}, maka dari itu, pemanggilan atribut \texttt{nama} masih dapat dilakukan pada kelas \texttt{Pejabat} tanpa harus mendeklarasikan atribut ini karena atribut \texttt{nama} ini adalah hasil dari pewarisan kelas \texttt{Pegawai}.

\section{Ekstensi}

\section{Kelas Data}

\section{Kelas Tertutup}

\section{Generik}

\section{Kelas Bersarang}

\section{Kelas \textit{Enum}}

\section{Ekspresi Objek dan Deklarasi}

\section{Delegasi}

\section{Mendelegasikan Properti}