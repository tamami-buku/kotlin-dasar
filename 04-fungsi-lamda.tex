\chapter{Fungsi dan Lamda}

\section{Fungsi}

Fungsi sebetulnya adalah sekumpulan kode program yang spesifik untuk menyelesaikan satu permasalahan. Fungsi dalam Kotlin ditandai dengan kata kunci \texttt{fun}.

Contoh kode berikut akan memberikan gambaran deklarasi dan penggunaan fungsi pada Kotlin :

\begin{lstlisting}
fun main(args: Array<String>) {
	cetak("tamami")
}

fun cetak(nama: String) {
	println("nama : $nama")
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
nama : tamami
\end{lstlisting}

Bila kita perhatikan, sebetulnya deklarasi fungsi \texttt{main} pada baris ke-1 sampai dengan baris ke-3 adalah deklarasi fungsi yang selalu kita sertakan, karena fungsi ini wajib ada apabila aplikasi ingin kita jalankan.

Fungsi \texttt{main} ini hanya menerima sebuah argumen bertipe \texttt{Array} yang sebetulnya akan terisi apabila kita menyertakan parameter pada saat menjalankan aplikasi. Kita akan coba ini nanti.

Yang kedua adalah fungsi dengan nama \texttt{cetak} yang deklarasinya ada pada baris ke-5 sampai dengan baris ke-7. Fungsi ini sederhana, hanya meminta sebuah parameter bertipe \texttt{String} dan mencetak parameter tersebut ke monitor.

Sekarang coba ubah kode di atas menjadi seperti berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	cetak(args[0])
}

fun cetak(nama: String) {
	println("nama : $nama")
}
\end{lstlisting}

Setelah melakukan \textit{compile}, jalankan aplikasi dengan memberikan parameter pada program yang dijalankan. Caranya adalah dengan menambahkan teks setelah nama \textit{file} utamanya, misalkan nama \textit{file} kode yang saya buat adalah \texttt{Test.kt}, setelah melalui proses \textit{compile}, menghasilkan \textit{file} dengan nama \texttt{TestKt.class}.

Cara eksekusi \textit{file} \texttt{TestKt.class} tersebut adalah dengan cara berikut :

\begin{lstlisting}
> kotlin TestKt [parameter]
\end{lstlisting}

Kali ini kita coba mengganti bagian \texttt{[parameter]} dengan teks \texttt{tamami}, perintah lengkapnya adalah sebagai berikut :

\begin{lstlisting}
> kotlin TestKt tamami
\end{lstlisting}

Hasil yang dikeluarkan dari pemanggilan kode program di atas adalah sebagai berikut :

\begin{lstlisting}
nama : tamami
\end{lstlisting}

Terlihat bahwa teks \texttt{tamami} yang menjadi parameter pertama, akan dilewatkan sebagai parameter di pemanggilan fungsi \texttt{cetak} seperti di baris ke-2, yang kemudian di cetak ke layar sebagaimana perintah pada baris ke-6.

\subsection{Cara Penggunaan}

\subsubsection{Notasi Infix}

Apa itu notasi \textit{infix}, notasi ini sebetulnya membuat pemanggilan sebuah fungsi menjadi seperti operator. Mungkin akan lebih mudah bila disajikan dalam bentuk kode program berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var nama = "tamami"
	
	println(nama sambung "Selamat Datang")
}

infix fun String.sambung(data: String): String {
	return "$this $data"
}
\end{lstlisting}

Sehingga hasil yang muncul ke layar adalah sebagai berikut :

\begin{lstlisting}
tamami Selamat Datang
\end{lstlisting}

Perhatikan pada baris ke-4, kita melihat bahwa fungsi \texttt{sambung} yang dideklarasikan pada baris ke-7 sampai dengan baris ke-9, karena memiliki kata kunci \texttt{infix} dapat berbentuk seperti operator biasa, cara memanggilnya tidak seperti kondisi fungsi pada umumnya.

Pada baris ke-8, kita melihat ada 2 (dua) variabel yang dipanggil, yaitu \texttt{\$this} yang isinya adalah \texttt{String} yang akan disambung, dan variabel \texttt{\$data} yang isinya adalah \texttt{String} sambungannya.

Beberapa hal agar model \textit{infix} ini dapat diimplementasikan yaitu :

\begin{enumerate}
	\item Fungsi yang dideklarasikan merupakan anggota dari kelas (berada dalam sebuah kelas) atau merupakan fungsi ekstensi dari suatu kelas..
	\item Fungsi ini hanya memiliki sebuah parameter
	\item Fungsi ini harus dideklarasikan dengan kata kunci \texttt{infix}.
\end{enumerate}

\subsubsection{Parameter}

Parameter seperti halnya variabel atau properti, harus dideklarasikan dengan format \texttt{[nama] : [tipe data]}, nama pada kondisi deklarasi parameter wajib menyertakan tipe data secara eksplisit. Tiap parameter pada konstruktor atau fungsi dipisahkan dengan koma.

Coba perhatikan fungsi \texttt{sambung} pada kode sebelumnya, disana ada sebuah parameter dengan nama \texttt{data} dengan tipe data berupa \texttt{String}. Deklarasinya harus berbentuk seperti ini.

\subsubsection{Parameter \textit{Default}}

Sebuah fungsi dapat memiliki parameter yang secara \textit{default} sudah memiliki nilai. Parameter-parameter ini dapat dilewatkan saat memanggil fungsi. Contoh kodenya adalah sebagai berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var pegawai = Pegawai()
	pegawai.setBio("tamami")
	
	println("nama : ${pegawai.nama}")
	println("jabatan : ${pegawai.jabatan}")
}

class Pegawai {
	var nama: String = ""
	var jabatan: String = ""
	
	fun setBio(nama: String, jabatan: String = "STAF") {
		this.nama = nama
		this.jabatan = jabatan
	}
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
nama : tamami
jabatan : STAF
\end{lstlisting}

Perhatikan pada baris ke-3 dari kode di atas, bahwa pemanggilan fungsi \texttt{setBio} milik kelas \texttt{Pegawai} hanya menyertakan sebuah parameter sedangkan pada deklarasinya membutuhkan 2 (dua) buah parameter, yaitu \texttt{nama} dan \texttt{jabatan}. 

Namun karena parameter \texttt{jabatan} memiliki nilai \textit{default} berupa teks \texttt{STAF}, maka parameter ini dapat dilewatkan, karena akan diisikan otomatis dengan teks \texttt{STAF}.

Maka dari itu hasil keluaran yang kita dapatkan adalah seperti tampilan di atas.

Apabila ada kelas turunan yang melakukan \textit{override} terhadap fungsi yang memiliki nilai \textit{default}, maka aturannya tidak boleh didefinisikan ulang nilai \textit{default}nya pada kelas turunan, jadi kelas turunannya akan mengikuti nilai \textit{default} milik pendahulunya.

Kita perhatikan contoh kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var pegawai = Pejabat()
	pegawai.setBio("tamami")
	
	println("nama : ${pegawai.nama}")
	println("jabatan : ${pegawai.jabatan}")
}

open class Pegawai {
	var nama: String = ""
	var jabatan: String = ""
	
	open fun setBio(nama: String, jabatan: String = "STAF") {
		this.nama = nama
		this.jabatan = jabatan
	}
}

class Pejabat: Pegawai() {
	override fun setBio(nama: String, jabatan: String) {
		this.nama = nama
		if(jabatan.equals("STAF")) {
			println("Masa pejabat jabatannya staf")
			return
		}
		this.jabatan = jabatan
	}
}
\end{lstlisting}

Hasil keluaran untuk kode di atas adalah sebagai berikut :

\begin{lstlisting}
Masa pejabat jabatannya staf
nama : tamami
jabatan :
\end{lstlisting}

Lihatlah pada baris ke-19 sampai dengan baris ke-28, disini adalah tempat deklarasi kelas \texttt{Pejabat} yang sebetulnya adalah turunan dari kelas \texttt{Pegawai}, perhatikan kembali bahwa kelas \texttt{Pegawai} ini harus memiliki kata kunci \texttt{open} agar bisa diwariskan ke kelas di bawahnya, kemudian fungsi \texttt{setBio} milik kelas \texttt{Pegawai} juga diberikan kata kunci \texttt{open} agar kelas dibawahnya dapat melakukan \textit{override} terhadap fungsi ini.

Pada baris ke-20 fungsi \texttt{setBio} milik kelas \texttt{Pegawai} di \textit{override}, dimana pada parameter \texttt{jabatan} sudah tidak dapat lagi diberikan nilai \textit{default} karena nilai \textit{default} sudah diberikan pada kelas pendahulunya, yaitu kelas \texttt{Pegawai}.

Dan pada baris ke-22, kita lakukan seleksi, apabila nilai parameter \texttt{jabatan} masih berisi nilai \textit{default}, yaitu teks \texttt{STAF}, maka kita akan cetak informasi bahwa yang masuk kelas \texttt{Pejabat} ini tentunya harus sudah memberikan jabatan strukturan yang baru selain \texttt{STAF}, maka kemudian isi variabel / properti \texttt{jabatan} milik kelas \texttt{Pejabat} akan dikosongkan / tidak diisikan, sehingga hasil keluaran akan tampak seperti di atas.

\subsubsection{Argumen Bernama}

Parameter / argumen pada fungsi dapat diberikan nama parameternya untuk memudahkan pengisian. Contohnya coba perhatikan pada kode berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	var pegawai: Pegawai() 
	pegawai.setBio(nama="tamami, gaji=5000L) 
	
	println("nama : ${pegawai.nama}")
	println("jabatan : ${pegawai.jabatan}")
	println("gaji : ${pegawai.gaji}")
	println("jenis kelamin : ${pegawai.jenisKelamin}")
}

class Pegawai {
	var nama = ""
	var jabatan = ""
	var gaji = 0L
	var jenisKelamin = true
	
	fun setBio(nama: String, jabatan: String = "STAF", gaji: Long = 1500L,
			jenisKelamin: Boolean = true) {
		this.nama = nama
		this.jabatan = jabatan
		this.gaji = gaji
		this.jenisKelamin = jenisKelamin
	}
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
nama : tamami
jabatan : STAF
gaji : 5000
jenis kelamin : true
\end{lstlisting}

Penggunaan argumen / parameter bernama ini ada pada baris ke-3, dimana fungsi \texttt{setBio} milik kelas \texttt{Pegawai} hanya diisikan 2 (dua) parameter saja, yaitu \texttt{nama} dan \texttt{gaji}.

Dengan menggunaan penamaan parameter ini, mempermudah apabila ada banyak parameter, dan beberapa parameter sudah ada nilai \textit{default}nya, sehingga untuk mengganti atau mengisikan salah satu parameter cukup dikenali dengan nama parameternya.

Fasilitas ini tidak dapat digunakan apabila memanggil fungsi milik kelas Java.

\subsubsection{Pengembalian Unit}

Setiap fungsi pasti memiliki nilai kembalian, apabila tidak dituliskan secara eksplisit, sebetulnya tetap ada nilai kembalian berupa objek \texttt{Unit}, mirip seperti \texttt{void} di bahasa pemrograman Java, yang ditujukan untuk \textit{method} atau fungsi yang tidak memiliki nilai kembalian.

Perhatikan kode berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	cetak("tamami")
}

fun cetak(nama: String) {
	println("nama : $nama")
}
\end{lstlisting}

Hasil keluaran dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
nama : tamami
\end{lstlisting}

Pada baris ke-5 dari kode di atas yang mendeklarasikan fungsi \texttt{cetak} akan sama artinya bila kita ganti dengan deklarasi seperti kode berikut :

\begin{lstlisting}
fun cetak(nama: String): Unit {
	println("nama : $nama")
}
\end{lstlisting}

\subsubsection{Ekspresi Tunggal}

Untuk fungsi-fungsi yang hanya memiliki satu baris perintah, sebetulnya dapat menghilangkan tanda kurung kurawal (\texttt{\{\}}), dan isi dari baris perintahnya langsung dideklarasikan setelah tanda sama dengan (\texttt{=}).

Hal lain adalah, tipe data kembalian dapat dihilangkan, karena \textit{compiler} akan otomatis melakukan deteksi terhadap ini. Berikut adalah contoh kodenya :

\begin{lstlisting}
fun main(args: Array<String>) {
	cetak("tamami")
}

fun cetak(nama: String) = println("nama : $nama")
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
nama : tamami
\end{lstlisting}

Pada baris ke-5 adalah contoh dari ekspresi tunggal dari fungsi \texttt{cetak}. Deklarasi fungsinya sama saja seperti fungsi pada umumnya, hanya saja tanda kurung kurawal dihilangkan, dan diganti dengan tanda sama dengan (\texttt{=}) dan langsung mendeklarasikan isi dari fungsi \texttt{cetak}.

\subsubsection{Argumen Dinamis}

Dalam kotlin, dimungkin kita membuat sebuah fungsi dengan jumlah argumen / parameter dinamis, dimana bisa saja jumlah parameter hanya satu, dua, atau lebih dari itu. Mari kita lihat contoh kode berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	println(sum(1,3,5,7))
	println(sum(2,4,6))
}

fun sum(vararg data: Int): Int {
	var result = 0
	for(x in data) {
		result += x
	}
	
	return result
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
16
12
\end{lstlisting}

Terlihat bahwa pada baris ke-2 dan baris ke-3 sama-sama memanggil fungsi \texttt{sum} tetapi dengan jumlah parameter yang berbeda, baris ke-2 menggunakan 4 (empat) parameter, sedangkan pada baris ke-3 menggunakan hanya 3 (tiga) parameter.

Hal tersebut mungkin terjadi karena deklarasi fungsi \texttt{sum} pada baris ke-6, parameternya menggunakan kata kunci \texttt{vararg} sehingga jumlah parameter yang ada dapat lebih fleksibel.

\subsection{Skup Fungsi}

Seperti telah kita coba sebelumnya, fungsi di Kotlin tidak hanya berada di dalam kelas, melainkan dapat ditempatkan di tingat teratas dari \textit{file}. 

Bukan hanya ditempatkan di tingkatan teratas dari \textit{file}, fungsi juga dapat ditempatkan sebagai lokal, \textit{member} dari suatu kelas, atau yang telah kita bahas sebelumnya, sebagai fungsi ekstensi.

Fungsi ekstensi telah kita bahas pada materi sebelumnya, kita akan bahas mengenai apa itu fungsi lokal, dan fungsi \textit{member}.

\subsubsection{Fungsi Lokal}

Fungsi yang berada di dalam fungsi lain bisa disebut fungsi lokal, fungsi lokal ini dapat melakukan akses terhadap variabel yang dideklarasikan di fungsi atasnya, coba perhatikan kode berikut ini :

\begin{lstlisting}
fun main(args: Array<String>) {
	fun tambah(a: Int, b: Int) = a + b
	
	println(tambah(2,4))
}
\end{lstlisting}

Hasil keluaran dari kode di atas adalah sebagai berikut :

\begin{lstlisting}
6
\end{lstlisting}

Perhatikan pada baris ke-2, yaitu deklarasi fungsi \texttt{tambah} yang berada pada fungsi \texttt{main}, yang kemudian dipanggil pada baris ke-4 untuk dilihat hasilnya. 

\subsubsection{Fungsi Member}

Fungsi member ini sebetulnya sudah sering kita gunakan pada percobaan sebelumnya, fungsi ini menjadi anggota / member di dalam sebuah kelas. Perhatikan contoh berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	var mhs = Mahasiswa()
	
	mhs.cetakNama("tamami")
}

class Mahasiswa {
	fun cetakNama(nama: String) {
		println("nama : $nama")
	}
}
\end{lstlisting}

Hasil keluaran untuk kode di atas adalah sebagai berikut :

\begin{lstlisting}
nama : tamami
\end{lstlisting}

Deklarasi fungsi member untuk kode di atas ada pada baris ke-8 dengan nama \texttt{cetakNama}, karena fungsi ini berada di dalam kelas \texttt{Mahasiswa}.

\subsection{Fungsi Generik}

Seperti halnya Java, Kotlin pun dapat membuat fungsi generik dengan deklarasi tipe generik berupa kurung siku sebelum deklarasi nama fungsinya, perhatikan contoh kode berikut yang kita ubah dari kode sebelumnya :

\begin{lstlisting}
fun main(args: Array<String>) {
	var mhs = Mahasiswa()
	
	mhs.cetakData("tamami")
	mhs.cetakData(50L)	
}

class Mahasiswa {
	fun <T> cetakData(data: T) {
		println("data : $data")
	}
}
\end{lstlisting}

Hasil keluaran dari kode tersebut adalah sebagai berikut :

\begin{lstlisting}
data : tamami
data : 50
\end{lstlisting}

Deklarasi fungsi generik ini ada pada baris ke-9 sampai dengan baris ke-11. Terlihat bahwa sebelum nama fungsi, ada deklarasi generik dengan tanda \texttt{<T>}, dan tipe data ini dijadikan tipe data para parameter \texttt{data}.

Pemanggilan fungsi ini ada pada baris ke-4 dan baris ke-5, dimana pada baris ke-4 dipanggil dengan mengisikan tipe data \texttt{String} pada parameternya. Kemudian pada baris ke-5, parameter diisi dengan tipe data \texttt{Long}. Keduanya dapat diterima dan di proses, karena tipe data apapun yang dilewatkan melalui parameter tersebut akan dicetak ke layar.

\subsection{Fungsi rekursif}

Fungsi rekursif adalah fungsi yang memanggil dirinya sendiri dalam implementasinya. Misalnya saja, untuk sederhananya adalah fungsi perkalian dengan operasi sederhana berupa penjumlahan dan pengurangan. Kita lihat contoh kodenya berikut :

\begin{lstlisting}
fun main(args: Array<String>) {
	val hasil = kali(3,5)
	
	println(hasil)
}

fun kali(a: Int, b: Int): Int = if(b == 1) a else a + kali(a, b-1)
\end{lstlisting}

Hasil dari kode program di atas adalah sebagai berikut :

\begin{lstlisting}
15
\end{lstlisting}

Perhatikan bahwa di baris ke-7 ada deklarasi fungsi \texttt{kali} yang di dalamnya terdapat pemanggilan ke fungsi \texttt{kali} yang sama, namun dengan nilai yang berbeda, ini yang disebut fungsi rekursif.

Fungsi ini terlihat lebih sederhana daripada menggunakan perintah iterasi seperti berikut ini :

\begin{lstlisting}
fun kali(a: Int, b: Int): Int {
	var result = a
	var pengali = b
	
	if(b == 1) return a
	else {
		while(pengali > 1) {
			pengali--
			result += a
			println("$pengali : $result")
		}
		return result
	}
}
\end{lstlisting}

Hasil dari kode program di atas adalah seperti berikut ini :

\begin{lstlisting}
4 : 6
3 : 9
2 : 12
1 : 15
15
\end{lstlisting}

Dari kode iterasi yang panjang di atas, mendapatkan hasil yang sama dari sebuah perkalian.

Namun sayangnya, bentuk rekursif biasa seperti di atas sangat rentang sekali akan kesalahan yang dikenal dengan \textit{stack overflow}, karena tiap dipanggil sebuah fungsi, komputer akan menyiapkan memori sebesar kebutuhan fungsi tersebut, bayangkan saat rekursi yang terjadi sudah lebih dari kemampuan memori komputer menyiapkan ruang untuk itu.

Optimalisasi yang dilakukan di Kotlin adalah mendukung \textit{tail} rekursif, yaitu rekursif yang terjadi di belakang (bukan secara fisik, namun secara logika). Maksudnya rekursif yang telah dipanggil tidak akan ditunggu hasilnya untuk kemudian diproses kembali, melainkan prosesnya akan berlanjut ke fungsi berikutnya dan dapat menghilangkan fungsi sebelumnya dari memori.

Contoh kode programnya adalah sebagai berikut :

\begin{lstlisting}
\end{lstlisting}

\section{Fungsi Lanjutan dan Lamda}

\section{Fungsi Sebaris}

\section{\textit{Coroutines}}